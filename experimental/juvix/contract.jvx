Map = Data.Map

-- common module interfaces for data structures in Common?
MonoidMeasure : Common.Measure
MonoidMeasure =
  type T = Nat

  -- (<>) is normal semi-group  type class function
  (<>)    = (<>)
  measure = id


-- need OrdMap, as modules that one goes to can't be modules?
Accounts = Map.OrdMap Data.String MonoidMeasure

-- we send in the string module, as it has a total order
-- function named compare, that is also part of a general type class
Token =
  type Address  = s : String.T {String.length s == 36}

  type Storage = {
    total-supply : Nat.T;
    accounts     : Accounts.T { Accounts.measure-value == total-supply }
  }

  empty-storage : Storage
  empty-storage = {
    total-supply = 0;
    accounts     = Accounts.empty;
  }

  type T = {
    storage = Storage;
    version = Nat.T;
    name    = String.T;
    symbol  = Char.T;
    owner   = Address;
  }


Transaction =
  type Transfer = {
    from-account : Token.Address;
    to-account   : Token.Address;
    ammount      : Nat.T;
  }

  type Mint = {
    mint-amount     = Nat.T;
    mint-to-account = Token.Address;
  }

  type Burn = {
    burn-amount       = Nat.T;
    burn-from-account = Token.Address;
  }

  type Data =
    | Transfer : Transfer -> Data
    | Mint     : Mint     -> Data
    | Burn     : Burn     -> Data

  type T = {
    data               : Data;
    authorized-account : Token.Address;
  }


has-n : Accounts.T -> Token.Address -> Nat -> Bool
has-n accounts add to-transfer =
  case Accounts.select accounts add of
  | Just n  -> to-transfer <= n
  | Nothing -> False


account-sub : acc : Accounts.T
           -> add : Token.Address
           -> num : Nat.T {has-n acc add num}
           -> Accounts.T
account-sub accounts add number =
  case Accounts.select accounts add of
  | Just balance ->
     Accounts.put accounts ~key:add ~val:(balance - number)

account-add : Accounts.T -> Token.Address -> Nat.T -> Accounts.T
account-add accounts add number =
  Accounts.update accounts ~f:(number +) ~key:add



transfer-stor : stor   : Token.Storage
              -> ~from : Token.Address
              -> ~to   : Token.Address
              -> num   : Nat.T {has-n stor.accounts from num}
              -> Token.Storage
transfer-stor stor ~from:add_from ~to:add_to num =
  let new-acc = account-add (account-sub stor.accounts add_from) add-to num in
  -- This is valid, because the monoid and measure of account track this
  { total-supply = stor.total-supply
  ; accounts     = new-acc
  }



Validation : Module
  type T = Token.T -> Transaction.T -> Bool

  transfer : T
  burn     : T
  mint     : T
Validation =
  type T = Token.T -> Transaction.T -> Bool

  mint token tx =
    case tx.data of
    | Transaction.Mint ->
      token.owner == tx-tx-authorized-account
    | Transaction.Burn _ | Transaction.Transfer _ ->
      false

  transfer token tx =
    case tx.data of
    | Transaction.Transfer {from-account; amount} ->
      has-n token.storage.accounts from-account amount
      && tx.authroized-account == from-account
    | Transaction.Burn _ | Transaction.Mint _ ->
      false

  Burn token tx =
    case tx.data of
    | Transaction.Burn {burn-from-account; burn-ammount} ->
      has_n token.storage.accounts burn-from-account burn-amount
      && tx.authroized-account == burn-from-account
    | Transaction.Mint _ | Transaction.Transfer _ ->
      false


Operation =

  type TokenTransaction f =
    tok : Token.T -> tx : tx { f tok tx } -> Token.T

  transfer : TokenTransaction Validation.transfer
  transfer token transaction =
    case transaction.data of
    | Transfer {from-account; to-account; amount} ->
      { token
        with storage =
          transfer-stor token.storage
                        ~from:from_account
                        ~to:to_account
                        transfer_ammount
      }

  mint : TokenTransaction Validation.mint
  mint token transaction =
    case transaction.data of
    | Mint {mint-amount; mint-to-account} ->
      { token
        -- again safe to do because of tree structure
        with storage = {
          total-suply = token.storage.total_supply + mint-amount;
          accounts    = account-add token.storage.accounts mint-to-account mint-amount;
        }}


  burn : TokenTransaction Validation.mint
  burn token transaction =
    case transaction.data of
    | Burn {burn-amount; burn-from-account} ->
      { token
        -- again safe to do because of tree structure
        with storage = {
          total-suply = token.storage.total_supply - burn-amount;
          accounts    = account-sub token.storage.accounts burn-from-account burn-amount;
        }}

  type Error =
    | NotEnoughFunds
    | NotSameAccount
    | NotOwnerToken
    | NotEnoughTokens

  exec : Token.T -> Transaction.T -> Either.T Error Token.T
  exec token tx =
  case tx.data of
  | Transfer _ ->
    if | Validation.transfer token tx = Right (transfer token tx)
       | else                         = Left NotEnoughFunds
  | Mint _ ->
    if | Validation.mint token tx = Right (mint  token tx)
       | else                     = Left NotEnoughFunds
  | Burn _ ->
    if | Validation.burn token tx = Right (burn token tx)
       | else                     = Left NotEnoughTokens


-- validation proofs given after figuring out syntax see F* for them
