fileTypes:
    - ju
keyEquivalent: ^~J
name: Juvix
patterns:
  - include: '#comment_like'
  - include: '#numeric_literals'
  - include: '#string_literal'
  - include: '#char_literal'
  - match: '(?<!@|#)-\}'
    name: invalid
  - match: '(\()\s*(\))'
    name: constant.language.unit.juvix
    captures:
      '1': {name: punctuation.paren.juvix}
      '2': {name: punctuation.paren.juvix}
  - match: '(\()(#)\s*(#)(\))'
    name: constant.language.unit.unboxed.juvix
    captures:
      '1': {name: punctuation.paren.juvix}
      '2': {name: keyword.operator.hash.juvix}
      '3': {name: keyword.operator.hash.juvix}
      '4': {name: punctuation.paren.juvix}
  - match: '(\()\s*,[\s,]*(\))'
    name: support.constant.tuple.juvix
    captures:
      '1': {name: punctuation.paren.juvix}
      '2': {name: punctuation.paren.juvix}
  - match: '(\()(#)\s*,[\s,]*(#)(\))'
    name: support.constant.tuple.unboxed.juvix
    captures:
      '1': {name: punctuation.paren.juvix}
      '2': {name: keyword.operator.hash.juvix}
      '3': {name: keyword.operator.hash.juvix}
      '4': {name: punctuation.paren.juvix}
  - match: '(\[)\s*(\])'
    name: constant.language.empty-list.juvix
    captures:
      '1': {name: punctuation.bracket.juvix}
      '2': {name: punctuation.bracket.juvix}
  - begin: '(\b(?<!'')(module)|^(signature))(\b(?!''))'
    beginCaptures:
      '2': {name: keyword.other.module.juvix}
      '3': {name: keyword.other.signature.juvix}
    end: '(?=\b(?<!'')where\b(?!''))'
    name: meta.declaration.module.juvix
    patterns:
      - include: '#comment_like'
      - include: '#module_name'
      - include: '#module_exports'
      - match: '[a-z]+'
        name: invalid
  - include: '#ffi'
  - begin: '^(\s*)(class)(\b(?!''))'
    beginCaptures:
      '2': {name: keyword.other.class.juvix}
    end: >-
      (?x) # Detect end of class declaration:
               # 'where' keyword
         (?=(?<!')\bwhere\b(?!'))  
               # Decreasing indentation
         |(?=\}|;)      # Explicit indentation
         |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
             \1\s+\S    # - more indented, or
           | \s*        # - starts with whitespace, followed by:
             (?: $      #   - the end of the line (i.e. empty line), or
             |\{-[^@]   #   - the start of a block comment, or
             |--+       #   - the start of a single-line comment.
                (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                        # The double dash may not be followed by other operator characters
                        # (then it would be an operator, not a comment)
           )
    name: meta.declaration.class.juvix
    patterns:
      - include: '#comment_like'
      - include: '#where'
      - include: '#type_signature'
  # GADT declaration
  # must find `where` keyword on the same line
  # (only way to distinguish between GADT and ADT)
  - begin: >-
      (?x)
        ^(\s*)(data|newtype)(?:\s+(instance))?\s+
        # Keep consuming characters until:
        ((?:(?!
        # the equals symbol or the start of a single-line comment, or
          (?: 
            (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']]) # non-symbol
            (?:=|--+)
            (?![\p{S}\p{P}&&[^(),;\[\]`{}_"']])  # non-symbol
          )
        # the "where" or "deriving" keywords, or
        | (?:\b(?<!')(?:where|deriving)\b(?!'))
        # the start of a block comment.
        | {-
        #
        ).)*)
        (?=\b(?<!'')where\b(?!''))
    beginCaptures:
      '2': {name: keyword.other.$2.juvix}
      '3': {name: keyword.other.instance.juvix}
      '4': 
        patterns:
          - include: '#type_signature'
    name: meta.declaration.$2.generalized.juvix
    end: | 
      (?x) # Detect end of data declaration:
               # Deriving clause
         (?=(?<!')\bderiving\b(?!'))  
               # Decreasing indentation
         |(?=\}|;)      # Explicit indentation
         |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
             \1\s+\S    # - more indented, or
           | \s*        # - starts with whitespace, followed by:
             (?: $      #   - the end of the line (i.e. empty line), or
             |\{-[^@]   #   - the start of a block comment, or
             |--+       #   - the start of a single-line comment.
                (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                        # The double dash may not be followed by other operator characters
                        # (then it would be an operator, not a comment)
           )
    patterns:
      - include: '#comment_like'
      # Can't simply include 'where' pattern,
      # because it includes all of $self,
      # whereas we want something slightly different
      - begin: >-
          (?x)
            (?<!')\b(where)
            \s*(\{)(?!-)
        end: '\}'
        beginCaptures:
          '1': {name: keyword.other.where.juvix}
          '2': {name: punctuation.brace.juvix}
        endCaptures:
          '1': {name: punctuation.brace.juvix}
        patterns:
          - include: '#comment_like'
          - include: '#gadt_constructor'
          - match: ';'
            name: punctuation.semicolon.juvix
      - match: '\b(?<!'')(where)\b(?!'')'
        name: keyword.other.where.juvix
      - include: '#deriving'
      - include: '#gadt_constructor'
  - include: '#role_annotation'
  - name: 'meta.declaration.pattern.type.juvix'
    begin: '^(\s*)(pattern)\s+(.*?)\s+(::|∷)(?![\p{S}\p{P}&&[^(),;\[\]`{}_"'']])'
    beginCaptures:
      '2': {name: keyword.other.pattern.juvix}
      '3':
        patterns:
          - include: '#comma'
          - include: '#data_constructor'
      '4': {name: keyword.operator.double-colon.juvix}
    end: | 
      (?x) # Detect end of pattern type definition by decreasing indentation:
        (?=\}|;)       # Explicit indentation
        |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
            \1\s+\S    # - more indented, or
          | \s*        # - starts with whitespace, followed by:
            (?: $      #   - the end of the line (i.e. empty line), or
            |\{-[^@]   #   - the start of a block comment, or
            |--+       #   - the start of a single-line comment.
               (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                       # The double dash may not be followed by other operator characters
                       # (then it would be an operator, not a comment)
          )
    patterns:
      - include: '#type_signature'
  - name: 'meta.declaration.pattern.juvix'
    begin: '^\s*(pattern)\b(?!'')'
    captures:
      '1': {name: keyword.other.pattern.juvix}
    end: | 
      (?x) # Detect end of pattern type definition by decreasing indentation:
        (?=\}|;)       # Explicit indentation
        |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
            \1\s+\S    # - more indented, or
          | \s*        # - starts with whitespace, followed by:
            (?: $      #   - the end of the line (i.e. empty line), or
            |\{-[^@]   #   - the start of a block comment, or
            |--+       #   - the start of a single-line comment.
               (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                       # The double dash may not be followed by other operator characters
                       # (then it would be an operator, not a comment)
          )
    patterns:
      - include: '$self'
  # ADT declaration (no "where" keyword on the same line)
  - begin: >-
      (?x)
        # Data declaration
        ^(\s*)(data|newtype)(?:\s+(family|instance))?\s+
        # Keep consuming characters until:
        (((?!
        # the equals symbol or the start of a single-line comment, or
          (?: 
            (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']]) # non-symbol
            (?:=|--+)
            (?![\p{S}\p{P}&&[^(),;\[\]`{}_"']])  # non-symbol
          )
        # the "where" or "deriving" keywords, or
        | (?:\b(?<!')(?:where|deriving)\b(?!'))
        # the start of a block comment.
        | {-
        #
        ).)*)
    beginCaptures:
      '2': {name: keyword.other.$2.juvix}
      '3': {name: keyword.other.$3.juvix}
      '4':
        patterns:
          - include: '#type_signature'
    name: meta.declaration.$2.algebraic.juvix
    end: >-
      (?x) # Detect end of data declaration: 
           # Decreasing indentation
         (?=\}|;)      # Explicit indentation
         |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
             \1\s+\S    # - more indented, or
           | \s*        # - starts with whitespace, followed by:
             (?: $      #   - the end of the line (i.e. empty line), or
             |\{-[^@]   #   - the start of a block comment, or
             |--+       #   - the start of a single-line comment.
                (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                        # The double dash may not be followed by other operator characters
                        # (then it would be an operator, not a comment)
           )
    patterns:
      - include: '#comment_like'
      - include: '#deriving'
      - include: '#forall'
      - include: '#adt_constructor'
      - include: '#data_context'
      - include: '#record_decl'
      - include: '#type_signature'
  - name: 'meta.declaration.type.family.juvix'
    begin: >-
      (?x)
        # Type family
        ^(\s*)(type)\s+(family)\b(?!')
        # Keep consuming characters until:
        (((?!
        # the equals symbol or the start of a single-line comment, or
          (?: 
            (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']]) # non-symbol
            (?:=|--+)
            (?![\p{S}\p{P}&&[^(),;\[\]`{}_"']])  # non-symbol
          )
        # the "where" keyword, or
        | \b(?<!')where\b(?!')
        # the start of a block comment.
        | {-
        #
        ).)*)
    beginCaptures:
      '2': {name: keyword.other.type.juvix}
      '3': {name: keyword.other.family.juvix}
      '4':
        patterns:
          - include: "#comment_like"
          - include: '#where'
          - include: '#type_signature'
    end: | 
      (?x) # Detect end of type family by decreasing indentation:
        (?=\}|;)       # Explicit indentation
        |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
            \1\s+\S    # - more indented, or
          | \s*        # - starts with whitespace, followed by:
            (?: $      #   - the end of the line (i.e. empty line), or
            |\{-[^@]   #   - the start of a block comment, or
            |--+       #   - the start of a single-line comment.
               (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                       # The double dash may not be followed by other operator characters
                       # (then it would be an operator, not a comment)
          )
    patterns:
      - include: "#comment_like"
      - include: '#where'
      - include: '#type_signature'
  - name: 'meta.declaration.type.juvix'
    begin: >-
      (?x)
        # Type declaration
        ^(\s*)(type)(?:\s+(instance))?\s+
        # Keep consuming characters until:
        (((?!
        # the equals symbol, the start of a single-line comment, or a type signature
          (?: 
            (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']]) # non-symbol
            (?:=|--+|::|∷)
            (?![\p{S}\p{P}&&[^(),;\[\]`{}_"']])  # non-symbol
          )
        # the start of a block comment.
        | {-
        #
        ).)*)
    beginCaptures:
      '2': {name: keyword.other.type.juvix}
      '3': {name: keyword.other.instance.juvix}
      '4':
        patterns:
          - include: '#type_signature'
    end: | 
      (?x) # Detect end of type definition by decreasing indentation:
        (?=\}|;)       # Explicit indentation
        |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
            \1\s+\S    # - more indented, or
          | \s*        # - starts with whitespace, followed by:
            (?: $      #   - the end of the line (i.e. empty line), or
            |\{-[^@]   #   - the start of a block comment, or
            |--+       #   - the start of a single-line comment.
               (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                       # The double dash may not be followed by other operator characters
                       # (then it would be an operator, not a comment)
          )
    patterns:
      - include: '#type_signature'
  - begin: '^(\s*)(instance)(\b(?!''))'
    beginCaptures:
      '2': {name: keyword.other.instance.juvix}
    end: |
      (?x) # Detect end of instance declaration:
        # 'where' keyword
        (?=\b(?<!')(where)\b(?!'))
        # Decreasing indentation
        |(?=\}|;)      # Explicit indentation
        |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
            \1\s+\S    # - more indented, or
          | \s*        # - starts with whitespace, followed by:
            (?: $      #   - the end of the line (i.e. empty line), or
            |\{-[^@]   #   - the start of a block comment, or
            |--+       #   - the start of a single-line comment.
               (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                       # The double dash may not be followed by other operator characters
                       # (then it would be an operator, not a comment)
          )
    name: meta.declaration.instance.juvix
    patterns:
      - include: '#comment_like'
      - include: '#where'
      - include: '#type_signature'
  - begin: >-
      ^(\s*)(import)(\b(?!'))
    beginCaptures:
      '2': {name: keyword.other.import.juvix}
    end: |
      (?x) # Detect end of import
        # 'where' keyword
        (?=\b(?<!')(where)\b(?!'))
        # Decreasing indentation
        |(?=\}|;)      # Explicit indentation
        |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
            \1\s+\S    # - more indented, or
          | \s*        # - starts with whitespace, followed by:
            (?: $      #   - the end of the line (i.e. empty line), or
            |\{-[^@]   #   - the start of a block comment, or
            |--+       #   - the start of a single-line comment.
               (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                       # The double dash may not be followed by other operator characters
                       # (then it would be an operator, not a comment)
          )
    name: meta.import.juvix
    patterns:
      - include: '#comment_like'
      - include: '#where'
      - match: (qualified|as|hiding)
        captures:
          '1': {name: "keyword.other.$1.juvix"}
      - include: '#module_name'
      - include: '#module_exports'
  - include: '#deriving'
  - include: '#layout_herald'
  - include: '#keyword'
  - match: '^\s*(infix[lr]?)\s+(.*)'
    captures:
      '1': {name: "keyword.other.$1.juvix"}
      '2':
        patterns:
          - include: '#comment_like'
          - include: '#integer_literals'
          - include: "#infix_op"
    name: meta.fixity-declaration.juvix
  - include: '#start_type_signature'
  - include: '#overloaded_label'
  - include: '#type_application'
  - include: '#reserved_symbol'
  - include: '#fun_decl'
  - include: '#qualifier'
  - match: ':[\p{S}\p{P}&&[^(),;\[\]`{}_"'']]*'
    name: constant.other.operator.juvix
  - include: '#data_constructor'
  - include: '#prefix_op'
  - include: '#infix_op'
  - begin: '(\()(#)\s'
    end: '(#)(\))'
    beginCaptures:
      '1': {name: punctuation.paren.juvix}
      '2': {name: keyword.operator.hash.juvix}
    endCaptures:
      '1': {name: keyword.operator.hash.juvix}
      '2': {name: punctuation.paren.juvix}
    patterns:
      - include: '#comma'
      - include: '$self'
  - begin: '(\()'
    end: '(\))'
    beginCaptures:
      '1': {name: punctuation.paren.juvix}
    endCaptures:
      '1': {name: punctuation.paren.juvix}
    patterns:
      - include: '#comma'
      - include: '$self'
  - include: '#quasi_quote'
  - begin: '(\[)'
    end: '(\])'
    beginCaptures:
      '1': {name: punctuation.bracket.juvix}
    endCaptures:
      '1': {name: punctuation.bracket.juvix}
    patterns:
      - include: '#comma'
      - include: '$self'
  - include: '#record'
repository:
  block_comment:
    applyEndPatternLast: 1
    begin: '\{-'
    captures:
      '0': {name: punctuation.definition.comment.juvix}
    end: '-\}'
    name: comment.block.juvix
    patterns:
      - include: '#block_comment'
  comments:
    patterns:
      # Haddock block: consecutive double-dashed lines, the first one starting with `-- |` or `-- $`
      - begin: '^(\s*)(--\s[\|\$])'
        beginCaptures:
          '2': {name: punctuation.whitespace.comment.leading.juvix}
        end: '(?=^(?!\1--+(?![\p{S}\p{P}&&[^(),;\[\]`{}_"'']])))'
        name: comment.block.documentation.juvix
      # Haddock inline annotation (not necessarily at the start of a line)
      - begin: '(^[ \t]+)?(--\s[\^\*])'
        beginCaptures: 
          '1': {name: punctuation.whitespace.comment.leading.juvix}
        end: \n
        name: comment.line.documentation.juvix
      # Haddock block using {- -} comments
      - applyEndPatternLast: 1
        begin: '\{-\s?[\|\$\*\^]'
        captures:
          '0': {name: punctuation.definition.comment.juvix}
        end: '-\}'
        name: comment.block.documentation.juvix
        patterns:
          - include: '#block_comment'
      - begin: >-
          (^[ \t]+)?(?=--+(?![\p{S}\p{P}&&[^(),;\[\]`{}_"']]))
        beginCaptures:
          '1': {name: punctuation.whitespace.comment.leading.juvix}
        comment: 'Operators may begin with ''--'' as long as they are not entirely composed of ''-'' characters. This means comments can''t be immediately followed by an allowable operator character.'
        end: '(?!\G)'
        patterns:
          - begin: '--'
            beginCaptures: 
              '0': {name: punctuation.definition.comment.juvix}
            end: \n
            name: comment.line.double-dash.juvix
      - {include: '#block_comment'}
  comment_like:
    patterns:
      - include: '#cpp'
      - include: '#pragma'
      - include: '#comments'
  cpp:
    captures:
      '1': {name: punctuation.definition.preprocessor.c}
    comment: 'In addition to juvix''s "native" syntax, GHC permits the C preprocessor to be run on a source file.'
    match: '^(#).*$' # `#` must be the first character on the line
    name: meta.preprocessor.c
  where:
    patterns:
      - begin: >-
          (?x)
            (?<!')\b(where)
            \s*(\{)(?!-)
        end: '(\})'
        beginCaptures:
          '1': {name: keyword.other.where.juvix}
          '2': {name: punctuation.brace.juvix}
        endCaptures:
          '1': {name: punctuation.brace.juvix}
        patterns:
          - include: '$self'
          - match: ';'
            name: punctuation.semicolon.juvix
      - match: '\b(?<!'')(where)\b(?!'')'
        name: keyword.other.where.juvix
  layout_herald:
    begin: >-
      (?x)
        (?<!')\b(?:(where|let|m?do)|(of))
        \s*(\{)(?!-)
    end: '(\})'
    beginCaptures:
      '1': {name: keyword.other.$1.juvix}
      '2': {name: keyword.control.of.juvix}
      '3': {name: punctuation.brace.juvix}
    endCaptures:
      '1': {name: punctuation.brace.juvix}
    patterns:
      - include: '$self'
      - match: ';'
        name: punctuation.semicolon.juvix
  keyword:
    match: '\b(?<!'')(?:(where|let|in|default)|(m?do|if|then|else|case|of|proc|rec))\b(?!'')'
    captures:
      '1': {name: keyword.other.$1.juvix}
      '2': {name: keyword.control.$2.juvix}
  deriving:
    patterns:
      # Deriving (start of line)
      - begin: '^(\s*)(deriving)\s+(?:(via|stock|newtype|anyclass)\s+)?'
        beginCaptures:
          '2': {name: keyword.other.deriving.juvix}
          '3': {name: keyword.other.deriving.strategy.$3.juvix}
        end: >-
          (?x) # Detect end of deriving statement
            # Decreasing indentation
             (?=\}|;)      # Explicit indentation
            |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
                \1\s+\S    # - more indented, or
              | \s*        # - starts with whitespace, followed by:
                (?: $      #   - the end of the line (i.e. empty line), or
                |\{-[^@]   #   - the start of a block comment, or
                |--+       #   - the start of a single-line comment.
                   (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                           # The double dash may not be followed by other operator characters
                           # (then it would be an operator, not a comment)
              )
        patterns:
          - include: '#comment_like'
          - match: '(?<!'')\b(instance)\b(?!'')'
            name: keyword.other.instance.juvix
          - match: '(?<!'')\b(via|stock|newtype|anyclass)\b(?!'')'
            captures:
              '1': {name: keyword.other.deriving.strategy.$1.juvix }
          - include: '#type_signature'
        name: meta.deriving.juvix
      # Deriving (not start of line, parenthesised type)
      - begin: '(deriving)(?:\s+(stock|newtype|anyclass))?\s*(\()'
        beginCaptures:
          '1': {name: keyword.other.deriving.juvix}
          '2': {name: "keyword.other.deriving.strategy.$2.juvix"}
          '3': {name: punctuation.paren.juvix}
        end: '(\))'
        endCaptures:
          '1': {name: punctuation.paren.juvix}
        name: meta.deriving.juvix
        patterns:
          - include: '#type_signature'
      # Deriving (not start of line, unparenthesised type)
      - match: |
          (?x)
            (deriving)(?:\s+(stock|newtype|anyclass))?\s+
              ([\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)
              (\s+(via)\s+(.*)$)?
        captures:
          '1': {name: keyword.other.deriving.juvix}
          '2': {name: "keyword.other.deriving.strategy.$2.juvix"}
          '3': {patterns: [{include: '#type_signature'}]}
          '5': {name: keyword.other.deriving.strategy.via.juvix}
          '6': {patterns: [{include: '#type_signature'}]}
        name: meta.deriving.juvix
      - match: '(?<!'')\b(via)\b(?!'')'
        name: keyword.other.deriving.strategy.via.juvix
  prefix_op:
    patterns:
      - comment: >
          An operator cannot be composed entirely of '-' characters; 
          instead, it should be matched as a comment.
        match: >-
          (?x)
            (\()\s*(?!(?:--+|\.\.)\))(\#+|[\p{S}\p{P}&&[^(),;\[\]`{}_"']]+(?<!\#))\s*(\))
        captures:
          '1': {name: punctuation.paren.juvix}
          '2': {name: entity.name.function.infix.juvix}
          '3': {name: punctuation.paren.juvix}
  infix_op:
    patterns:
      - match: >-
          (?x)
            ((?:(?<!'')('')?[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'']*\.)*)
              (\#+|[\p{S}\p{P}&&[^(),;\[\]`{}_"']]+(?<!\#))
        comment: >
          In case this regex seems overly general, note that juvix permits 
          the definition of new operators which can be nearly any string of 
          punctuation characters, such as $%^&*.
        captures:
          '1': {name: keyword.operator.promotion.juvix}
          '2': {name: entity.name.namespace.juvix}
          '3': {name: keyword.operator.infix.juvix}
      - match: >-
          (`)((?:[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'']*\.)*)([\p{Ll}\p{Lu}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'']*)(`)
        captures:
          '1': {name: punctuation.backtick.juvix}
          '2': {name: entity.name.namespace.juvix}
          '3':
            patterns:
              - include: '#data_constructor'
          '4': {name: punctuation.backtick.juvix}
        comment: |
          In case this regex seems unusual for an infix operator, note that juvix
          allows any ordinary function application (elem 4 [1..10]) to be rewritten
          as an infix expression (4 `elem` [1..10]).
        name: keyword.operator.function.infix.juvix
  module_exports:
    begin: \(
    beginCaptures:
      '0': {name: punctuation.paren.juvix}
    end: \)
    endCaptures:
      '0': {name: punctuation.paren.juvix}
    applyEndPatternLast: 1
    name: meta.declaration.exports.juvix
    patterns:
      - include: '#comment_like'
      - match: '\b(?<!'')(module)\b(?!'')'
        captures:
          '1': {name: keyword.other.module.juvix}
      - include: '#comma'
      - include: '#export_constructs'
      - begin: '\('
        beginCaptures:
          '0': {name: punctuation.paren.juvix}
        end: '\)'
        endCaptures:
          '0': {name: punctuation.paren.juvix}
        patterns:
          - include: '#comment_like'
          - include: '#record_wildcard'
          - match: >-
              (\()\s*(:[\p{S}\p{P}&&[^(),;\[\]`{}_"']]*)\s*(\))
            name: constant.other.operator.juvix
          - include: '#export_constructs'
          - include: '#comma'
  export_constructs:
    patterns:
      - include: '#comment_like'
      - begin: '\b(?<!'')(pattern)\b(?!'')'
        beginCaptures:
          '1': {name: keyword.other.pattern.juvix}
        end: >-
         (?x)
            # Data constructor
            ([\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)
            # Prefix form of symbolic constructor
            | (\()\s*(:[\p{S}\p{P}&&[^(),;\[\]`{}_"']]+)\s*(\))
        endCaptures:
          '1': {name: constant.other.juvix}
          '2': {name: punctuation.paren.juvix}
          '3': {name: constant.other.operator.juvix}
          '4': {name: punctuation.paren.juvix}
        patterns:
          - include: '#comment_like'
      - begin: '\b(?<!'')(type)\b(?!'')'
        beginCaptures:
          '1': {name: keyword.other.type.juvix}
        end: >-
         (?x)
            # Type name
            ([\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)
            # Prefix form of type operator
            | (\()\s*([\p{S}\p{P}&&[^(),;\[\]`{}_"']]+)\s*(\))
        endCaptures:
          '1': {name: storage.type.juvix}
          '2': {name: punctuation.paren.juvix}
          '3': {name: storage.type.operator.juvix}
          '4': {name: punctuation.paren.juvix}
        patterns:
          - include: '#comment_like'
      - include: '#record_wildcard'
      - include: '#reserved_symbol'
      - match: >-
          (\()\s*(:[\p{S}\p{P}&&[^(),;\[\]`{}_"']]*)\s*(\))
        name: storage.type.operator.juvix
      - match: >-
         (?<!')\b[\p{Ll}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*
        name: entity.name.function.juvix
      - match: >-
          (?<!')\b[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*
        name: storage.type.juvix
      - include: '#prefix_op'
  comma:
    match: ','
    name: punctuation.separator.comma.juvix
  module_name:
    match: >-
      (?<conid>[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*(\.\g<conid>)?)
    name: entity.name.namespace.juvix
  pragma:
    begin: '\{-#'
    end: '#-\}'
    name: meta.preprocessor.juvix
    patterns:
      - include: '#comments'
      # LANGUAGE extensions (as of GHC 8.10)
      - begin: >-
          (?xi)
          \b(?<!')(LANGUAGE)\b(?!')
        end: '(?=#-\})'
        beginCaptures:
          '1': {name: keyword.other.preprocessor.pragma.juvix}
        patterns:
          - include: '#comments'
          - match: >-
              (?x)
                \b(?<!')
                (?:No)?
                (?:AutoDeriveTypeable|DatatypeContexts|DoRec|IncoherentInstances|MonadFailDesugaring|MonoPatBinds|NullaryTypeClasses|OverlappingInstances|PatternSignatures|RecordPuns|RelaxedPolyRec)
                \b(?!')
            name: invalid.deprecated
          - match: >-
              (?x)
                \b(?<!')
                (
                (?:No)?
                (?:AllowAmbiguousTypes|AlternativeLayoutRuleTransitional|AlternativeLayoutRule|Arrows|BangPatterns|BinaryLiterals|CApiFFI|CPP|CUSKs|ConstrainedClassMethods|ConstraintKinds|DataKinds|DefaultSignatures|DeriveAnyClass|DeriveDataTypeable|DeriveFoldable|DeriveFunctor|DeriveGeneric|DeriveLift|DeriveTraversable|DerivingStrategies|DerivingVia|DisambiguateRecordFields|DoAndIfThenElse|BlockArguments|DuplicateRecordFields|EmptyCase|EmptyDataDecls|EmptyDataDeriving|ExistentialQuantification|ExplicitForAll|ExplicitNamespaces|ExtendedDefaultRules|FlexibleContexts|FlexibleInstances|ForeignFunctionInterface|FunctionalDependencies|GADTSyntax|GADTs|GHCForeignImportPrim|Generali(?:s|z)edNewtypeDeriving|ImplicitParams|ImplicitPrelude|ImportQualifiedPost|ImpredicativeTypes|TypeFamilyDependencies|InstanceSigs|ApplicativeDo|InterruptibleFFI|JavaScriptFFI|KindSignatures|LambdaCase|LiberalTypeSynonyms|MagicHash|MonadComprehensions|MonoLocalBinds|MonomorphismRestriction|MultiParamTypeClasses|MultiWayIf|NumericUnderscores|NPlusKPatterns|NamedFieldPuns|NamedWildCards|NegativeLiterals|HexFloatLiterals|NondecreasingIndentation|NumDecimals|OverloadedLabels|OverloadedLists|OverloadedStrings|PackageImports|ParallelArrays|ParallelListComp|PartialTypeSignatures|PatternGuards|PatternSynonyms|PolyKinds|PolymorphicComponents|QuantifiedConstraints|PostfixOperators|QuasiQuotes|Rank2Types|RankNTypes|RebindableSyntax|RecordWildCards|RecursiveDo|RelaxedLayout|RoleAnnotations|ScopedTypeVariables|StandaloneDeriving|StarIsType|StaticPointers|StrictData|Strict|TemplatejuvixQuotes|Templatejuvix|StandaloneKindSignatures|TraditionalRecordSyntax|TransformListComp|TupleSections|TypeApplications|TypeInType|TypeFamilies|TypeOperators|TypeSynonymInstances|UnboxedTuples|UnboxedSums|UndecidableInstances|UndecidableSuperClasses|UnicodeSyntax|UnliftedFFITypes|UnliftedNewtypes|ViewPatterns)
                )
                \b(?!')
            captures:
              '1': {name: keyword.other.preprocessor.extension.juvix}
          - include: '#comma'
      - begin: >-
          (?xi)
            \b(?<!')(SPECIALI(?:S|Z)E)
            (?:
            \s*( \[ [^\[\]]* \])?\s*
            |\s+
            )
            (instance)\b(?!')
        end: '(?=#-\})'
        beginCaptures:
          '1': {name: keyword.other.preprocessor.pragma.juvix}
          '2':
            patterns:
              - include: '#inline_phase'
          '3': {name: keyword.other.instance.juvix}
        patterns:
          - include: '#type_signature'
      - begin: >-
          (?xi)
            \b(?<!')(SPECIALI(?:S|Z)E)\b(?!')
            (?:\s+(INLINE)\b(?!'))?
            (?:\s*(\[ [^\[\]]* \])?)
            \s*
        end: '(?=#-\})'
        beginCaptures:
          '1': {name: keyword.other.preprocessor.pragma.juvix}
          '2': {name: keyword.other.preprocessor.pragma.juvix}
          '3':
            patterns:
              - include: '#inline_phase'
        patterns:
          - include: '$self'
      - match: >-
          (?xi)
          \b(?<!')
            (LANGUAGE|OPTIONS_GHC|OPTIONS_HADDOCK|OPTIONS|INCLUDE
            |MINIMAL|UNPACK|OVERLAPS|INCOHERENT
            |NOUNPACK|SOURCE|OVERLAPPING|OVERLAPPABLE|INLINE
            |NOINLINE|INLINE?ABLE|CONLIKE|LINE|COLUMN|RULES
            |COMPLETE)\b(?!')
        name: keyword.other.preprocessor.juvix
      - begin: '(?i)\b(DEPRECATED|WARNING)\b'
        beginCaptures:
          '1': {name: keyword.other.preprocessor.pragma.juvix}
        end: '(?=#-\})'
        patterns:
          - include: '#comments'
          - include: '#string_literal'
  liquid_juvix:
    name: block.liquidjuvix.juvix
    begin: '\{-@'
    end: '@-\}'
    patterns:
      - include: '$self'
  data_context:
    match: |
      (?x)
        (.*)
        (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']])
        (=>|⇒)
        (?![\p{S}\p{P}&&[^(),;\[\]`{}_"']])
    captures:
      '1':
         patterns:
            # Need to highlight the left of a context arrow => as a type,
            # but need to know when to stop: when we see a = or ::
            # that is not guarded by parentheses:
            #
            #   foo :: abc => def
            #         ^^^^^^^
            #
            #   foo :: forall (a :: T). C a => B
            #         ^^^^^^^^^^^^^^^^^^^^^^^^
            #
            - include: '#comment_like'
            - include: '#forall'
            - begin: '(?=''?\()'
              end: '(?=\))'
              patterns:
                - include: '#type_signature'
            - begin: '(?=''?\[)'
              end: '(?=\])'
              patterns:
                - include: '#type_signature'
            - match: >-
                (?x)
                  (\S*)\s*
                  (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']])
                  (::|∷|=)
                  (?![\p{S}\p{P}&&[^(),;\[\]`{}_"']])
              captures:
                '1':
                  patterns:
                    - include: '#comment_like'
                    - include: '#forall'
                    - include: '#record_decl_field'
                '2':
                  patterns:
                    - include: '#reserved_symbol'
                '3':
                  patterns:
                    - include: '#type_signature'
            - include: '#type_signature'
      '2': {name: keyword.operator.big-arrow.juvix}
  data_constructor:
    patterns:
      - match: >-
          \b(?<!')[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*(?![\.'\w])
        name: constant.other.juvix
      - match: >-
          (\()\s*(:[\p{S}\p{P}&&[^(),;\[\]`{}_"']]*)\s*(\))
        name: constant.other.operator.juvix
  qualifier:
    match: >-
      \b(?<!')[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*\.
    name: entity.name.namespace.juvix
  record_decl:
    begin: '({)(?!-)'
    beginCaptures:
      '1': {name: punctuation.brace.juvix}
    end: '(?<!-)(})'
    endCaptures:
      '1': {name: punctuation.brace.juvix}
    name: meta.record.definition.juvix
    patterns:
      - include: '#comment_like'
      - include: '#record_decl_field'
  record:
    begin: '({)(?!-)'
    beginCaptures:
      '1': {name: punctuation.brace.juvix}
    end: '(?<!-)(})'
    endCaptures:
      '1': {name: punctuation.brace.juvix}
    name: meta.record.juvix
    patterns:
      - include: '#comment_like'
      - include: '#record_field'
  record_decl_field:
    begin: |
      (?x)
        (?:([\p{Ll}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)
          |(\()\s*([\p{S}\p{P}&&[^(),;\[\]`{}_"']]+)\s*(\))
        )
    end: '(,)|(?=})'
    beginCaptures:
      '1': {name: variable.other.member.definition.juvix}
      '2': {name: punctuation.paren.juvix}
      '3': {name: variable.other.member.definition.juvix}
      '4': {name: punctuation.paren.juvix}
    endCaptures:
      '1': {name: punctuation.comma.juvix}
    patterns:
      - include: '#comment_like'
      - include: '#comma'
      - include: '#double_colon'
      - include: '#type_signature'
      - include: '#record_decl_field'
  record_wildcard:
    match: >- 
      (?x)
        (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']])
        (\.\.)
        (?![\p{S}\p{P}&&[^(),;\[\]`{}_"']])
    captures:
      '1': {name: variable.other.member.wildcard.juvix}
  record_field:
    patterns:
      - begin: |
          (?x)
            (?:([\p{Ll}\p{Lu}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}\.']*)
              |(\()\s*([\p{S}\p{P}&&[^(),;\[\]`{}_"']]+)\s*(\))
            )
        end: '(,)|(?=})'
        beginCaptures:
          '1': 
            name: variable.other.member.juvix
            patterns:
              - include: '#qualifier'
          '2': {name: punctuation.paren.juvix}
          '3': {name: variable.other.member.juvix}
          '4': {name: punctuation.paren.juvix}
        endCaptures:
          '1': {name: punctuation.comma.juvix}
        patterns:
          - include: '#comment_like'
          - include: '#comma'
          - include: '$self'
      - include: '#record_wildcard'
  role_annotation:
    patterns:
      - begin: '^(\s*)(type)\s+(role)\b(?!'')'
        beginCaptures:
          '2': {name: keyword.other.type.juvix}
          '3': {name: keyword.other.role.juvix}
        end: >-
          (?x) # Detect end of block by decreasing indentation:
            (?=\}|;)       # Explicit indentation
            |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
                \1\s+\S    # - more indented, or
              | \s*        # - starts with whitespace, followed by:
                (?: $      #   - the end of the line (i.e. empty line), or
                |\{-[^@]   #   - the start of a block comment, or
                |--+       #   - the start of a single-line comment.
                   (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                           # The double dash may not be followed by other operator characters
                           # (then it would be an operator, not a comment)
              )
        name: meta.role-annotation.juvix
        patterns:
          - include: '#comment_like'
          - include: '#type_constructor'
          - match: '\b(?<!'')(nominal|representational|phantom)\b(?!'')'
            captures:
              '1': {name: "keyword.other.role.$1.juvix"}
  fun_decl:
    begin: |
      (?x)^(\s*)
        (?<fn>
          (?:
            [\p{Ll}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*\#*
          | \(\s*
              (?!--+\))
              [\p{S}\p{P}&&[^(),:;\[\]`{}_"']]
              [\p{S}\p{P}&&[^(),;\[\]`{}_"']]*
            \s*\)
          )
          (?:\s*,\s*\g<fn>)?
        )
        \s*(?<![\p{S}\p{P}&&[^\),;\]`}_"']])(::|∷)(?![\p{S}\p{P}&&[^\(,;\[`{_"']])
    beginCaptures:
      '2':
        name: entity.name.function.juvix
        patterns:
          - include: '#reserved_symbol'
          - include: '#prefix_op'
      '3': {name: keyword.operator.double-colon.juvix}
    name: meta.function.type-declaration.juvix
    patterns:
      - include: '#type_signature'
    end: |
      (?x)
        # End of type annotation:
          # To the left of a reserved symbolic keyword such as = or <-
        (?= 
            # non-symbolic character
            (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']])
            # symbolic keyword except (->)
            ((<-|←)|(=)|(-<|↢)|(-<<|⤛))
            # non-symbolic character
            ([(),;\[\]`{}_"']|[^\p{S}\p{P}])
        )
        # Decreasing indentation:
        |(?=\}|;)      # Explicit indentation
        |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
            \1\s+\S    # - more indented, or
          | \s*        # - starts with whitespace, followed by:
            (?: $      #   - the end of the line (i.e. empty line), or
            |\{-[^@]   #   - the start of a block comment, or
            |--+       #   - the start of a single-line comment.
               (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                       # The double dash may not be followed by other operator characters
                       # (then it would be an operator, not a comment)
          )
  adt_constructor:
    patterns:
      - include: '#comment_like'
      - begin: >-
          (?x)
            (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']]) # non-symbol
            (?:(=)|(\|))
            (?![\p{S}\p{P}&&[^(),;\[\]`{}_"']])  # non-symbol
        beginCaptures:
          '1': {name: keyword.operator.eq.juvix}
          '2': {name: keyword.operator.pipe.juvix}
        end: >-
          (?x)
            (?: # Infix data constructor
              # First argument
              (?:
              # Simple type
                (?<!')\b((?:[\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'\.])+)
              # Type inside balanced parentheses
              | ('? # Optional promotion tick
                  (?<paren>
                    \(          # Opening parenthesis
                    (?:
                      [^\(\)]*  # Match non-parentheses
                    | \g<paren> # or recurse into further depth
                    )*
                    \)          # Closing parenthesis
                  )
                )
              # Type inside balanced brackets
              | ('? # Optional promotion tick
                  (?<brac>
                    \[          # Opening bracket
                    (?:
                      [^\[\]]*  # Match non-brackets
                    | \g<brac>  # or recurse into further depth
                    )*
                    \]          # Closing bracket
                  )
                )
              )
              # Then either
              \s*
                # - a symbolic infix constructor, or
              (?:(?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']])(:[\p{S}\p{P}&&[^(),;\[\]`{}_"']]*)
                # - an alphabetic infix constructor
              | (`)([\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)(`)
              )
            ) # Otherwise, prefix data constructor, either:
            | # - an alphabetic data constructor e.g. "Cons_123"
              (?:(?<!')\b([\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*))
            | # - a symbolic (prefix) data constructor
              (\()\s*(:[\p{S}\p{P}&&[^(),;\[\]`{}_"']]*)\s*(\))
            | # Otherwise, try to fail early to avoid excessive backtracking (https://github.com/metastatedev/juvix/issues/161)
                # Fail when detecting a lowercase identifier and then something not starting with a tick or colon
                (?=\b(?<!')(?!(?:forall|deriving)\s)[\p{Ll}_]\S+\s+[^`:])
                # Fail when seeing another equal signs or pipe symbol
               |(?=
                  (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']]) # non-symbol
                  (?:=|\|)
                  (?![\p{S}\p{P}&&[^(),;\[\]`{}_"']])  # non-symbol
                )
        endCaptures:
          '1':
            patterns:
             - include: '#type_signature'
          '2':
            patterns:
              - include: '#type_signature'
          '4':
            patterns:
              - include: '#type_signature'
          '6': {name: constant.other.operator.juvix}
          '7': {name: punctuation.backtick.juvix}
          '8': {name: constant.other.juvix}
          '9': {name: punctuation.backtick.juvix}
          '10': {name: constant.other.juvix}
          '11': {name: punctuation.paren.juvix}
          '12': {name: constant.other.operator.juvix}
          '13': {name: punctuation.paren.juvix}
        patterns:
          - include: '#comment_like'
          - include: '#deriving'
          - include: '#record_decl'
          - include: '#forall'
          - include: '#data_context'
          - include: '#type_signature'
  gadt_constructor:
    patterns:
      # GADT constructor on start of line
      - begin: >-
          (?x)
             ^(\s*)
                (?:
                  (\b(?<!')[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)
                |(\()\s*(:[\p{S}\p{P}&&[^(),;\[\]`{}_"']]*)\s*(\))
                )
        beginCaptures:
          '2': {name: constant.other.juvix}
          '3': {name: punctuation.paren.juvix}
          '4': {name: constant.other.operator.juvix}
          '5': {name: punctuation.paren.juvix}
        end: |
          (?x)
            # GADT constructor ends
            (?=\b(?<!'')deriving\b(?!'))  
                  # Decreasing indentation
            |(?=\}|;)      # Explicit indentation
            |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
                \1\s+\S    # - more indented, or
              | \s*        # - starts with whitespace, followed by:
                (?: $      #   - the end of the line (i.e. empty line), or
                |\{-[^@]   #   - the start of a block comment, or
                |--+       #   - the start of a single-line comment.
                   (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                           # The double dash may not be followed by other operator characters
                           # (then it would be an operator, not a comment)
              )
        patterns:
          - include: '#comment_like'
          - include: '#deriving'
          - include: '#double_colon'
          - include: '#record_decl'
          - include: '#type_signature'
      # Remaining case: GADT constructor not on start of line
      - begin: >-
          (?x)
            (\b(?<!')[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}]*) # named constructor
           |(\()\s*(:[\p{S}\p{P}&&[^(),;\[\]`{}_"']]*)\s*(\))    # prefix operator
        beginCaptures:
          '1': {name: constant.other.juvix}
          '2': {name: punctuation.paren.juvix}
          '3': {name: constant.other.operator.juvix}
          '4': {name: punctuation.paren.juvix}
        end: '(?=;|\}|$)'
        patterns:
          - include: '#comment_like'
          - include: '#deriving'
          - include: '#double_colon'
          - include: '#record_decl'
          - include: '#type_signature'
  type_application:
    patterns:
      - begin: '(?<=[\s,;\[\]{}"])(@)('')?(\()'
        beginCaptures: 
          '1': {name: keyword.operator.prefix.at.juvix}
          '2': {name: keyword.operator.promotion.juvix}
          '3': {name: punctuation.paren.juvix}
        end: '\)'
        endCaptures:
          '0': {name: punctuation.paren.juvix}
        name: meta.type-application.juvix
        patterns:
          - include: '#type_signature'
      - begin: '(?<=[\s,;\[\]{}"])(@)('')?(\[)'
        beginCaptures: 
          '1': {name: keyword.operator.prefix.at.juvix}
          '2': {name: keyword.operator.promotion.juvix}
          '3': {name: punctuation.bracket.juvix}
        end: '\]'
        name: meta.type-application.juvix
        endCaptures:
          '0': {name: punctuation.bracket.juvix}
        patterns:
          - include: '#type_signature'
      - begin: '(?<=[\s,;\[\]{}"])(@)(?=\")'
        beginCaptures: 
          '1': {name: keyword.operator.prefix.at.juvix}
        end: '(?<=\")'
        name: meta.type-application.juvix
        patterns:
          - include: '#string_literal'
      - begin: '(?<=[\s,;\[\]{}"])(@)(?=[\p{Ll}_\p{Lu}\p{Lt}\p{Nd}''])'
        beginCaptures: 
          '1': {name: keyword.operator.prefix.at.juvix}
        end: '(?![\p{Ll}_\p{Lu}\p{Lt}\p{Nd}''])'
        name: meta.type-application.juvix
        patterns:
          - include: '#type_signature'
  type_signature:
    patterns:
      - include: '#comment_like'
      - match: '('')?(\()\s*(\))'
        captures:
          '1': {name: keyword.operator.promotion.juvix}
          '2': {name: punctuation.paren.juvix}
          '3': {name: punctuation.paren.juvix}
        name: support.constant.unit.juvix
      - match: '(\()(#)\s*(#)(\))'
        name: support.constant.unit.unboxed.juvix
        captures:
          '1': {name: punctuation.paren.juvix}
          '2': {name: keyword.operator.hash.juvix}
          '3': {name: keyword.operator.hash.juvix}
          '4': {name: punctuation.paren.juvix}
      - match: '('')?(\()\s*,[\s,]*(\))'
        captures:
          '1': {name: keyword.operator.promotion.juvix}
          '2': {name: punctuation.paren.juvix}
          '3': {name: punctuation.paren.juvix}
        name: support.constant.tuple.juvix
      - match: '(\()(#)\s*(#)(\))'
        name: support.constant.unit.unboxed.juvix
        captures:
          '1': {name: punctuation.paren.juvix}
          '2': {name: keyword.operator.hash.juvix}
          '3': {name: keyword.operator.hash.juvix}
          '4': {name: punctuation.paren.juvix}
      - match: '(\()(#)\s*,[\s,]*(#)(\))'
        captures:
          '1': {name: punctuation.paren.juvix}
          '2': {name: keyword.operator.hash.juvix}
          '3': {name: keyword.operator.hash.juvix}
          '4': {name: punctuation.paren.juvix}
        name: support.constant.tuple.unboxed.juvix
      - match: '('')?(\[)\s*(\])'
        captures:
          '1': {name: keyword.operator.promotion.juvix}
          '2': {name: punctuation.bracket.juvix}
          '3': {name: punctuation.bracket.juvix}
        name: support.constant.empty-list.juvix
      - include: '#integer_literals'
      - match: '(::|∷)(?![\p{S}\p{P}&&[^(),;\[\]`{}_"'']])'
        name: keyword.operator.double-colon.juvix
      - include: '#forall'
      - match: '=>|⇒'
        name: keyword.operator.big-arrow.juvix
      - include: '#string_literal'
      - match: '''[^'']'''
        name: invalid
      - include: '#type_application'
      - include: '#reserved_symbol'
      - include: '#type_operator'
      - include: '#type_constructor'
      - begin: '(\()(#)'
        end: '(#)(\))'
        beginCaptures:
          '1': {name: punctuation.paren.juvix}
          '2': {name: keyword.operator.hash.juvix}
        endCaptures:
          '1': {name: keyword.operator.hash.juvix}
          '2': {name: punctuation.paren.juvix}
        patterns:
          - include: '#comma'
          - include: '#type_signature'
      - begin: '('')?(\()'
        end: '(\))'
        beginCaptures:
          '1': {name: keyword.operator.promotion.juvix}
          '2': {name: punctuation.paren.juvix}
        endCaptures:
          '1': {name: punctuation.paren.juvix}
        patterns:
          - include: '#comma'
          - include: '#type_signature'
      - begin: '('')?(\[)'
        end: '(\])'
        beginCaptures:
          '1': {name: keyword.operator.promotion.juvix}
          '2': {name: punctuation.bracket.juvix}
        endCaptures:
          '1': {name: punctuation.bracket.juvix}
        patterns:
          - include: '#comma'
          - include: '#type_signature'
      - include: '#type_variable'
  double_colon:
    match: '\s*(::|∷)(?![\p{S}\p{P}&&[^(),;\[\]`{}_"'']])\s*'
    captures:
      '1': {name: keyword.operator.double-colon.juvix}
  start_type_signature:
    patterns:
      - begin: '^(\s*)(::|∷)(?![\p{S}\p{P}&&[^\(,;\[`{_"'']])\s*'
        beginCaptures:
          '2': {name: keyword.operator.double-colon.juvix}
        end: >-
          (?x)
            # End type annotation when seeing one of:
            (?=
              \#?\)                             # closing parenthesis
              |\]                               # closing bracket
              |,                                # comma
              |(?<!')\b(in|then|else|of)\b(?!') # keyword
              |                                 # symbolic keyword except (->)
                (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']])
                (?:
                   (\\|λ)
                  |(<-|←)
                  |(=)
                  |(-<|↢)
                  |(-<<|⤛)
                )
                ([(),;\[\]`{}_"']|[^\p{S}\p{P}])
              |(\#|@)-\}                             # End of annotation block (Liquidjuvix or pragma)
              # Decreasing indentation:
              | (?=\}|;)     # Explicit indentation
              |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
                  \1\s*\S    # - equally indented, or
                | \s*        # - starts with whitespace, followed by:
                  (?: $      #   - the end of the line (i.e. empty line), or
                  |\{-[^@]   #   - the start of a block comment, or
                  |--+       #   - the start of a single-line comment.
                     (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                             # The double dash may not be followed by other operator characters
                             # (then it would be an operator, not a comment)
                )
            )
        patterns:
          - include: '#type_signature'
        name: meta.type-declaration.juvix
      - begin: '(?<![\p{S}\p{P}&&[^\(,;\[`{_"'']])(::|∷)(?![\p{S}\p{P}&&[^\(,;\[`{_"'']])'
        beginCaptures:
          '1': {name: keyword.operator.double-colon.juvix}
        end: >-
          (?x)
            # End type annotation when seeing one of:
            (?=
              \#?\)                             # closing parenthesis
              |\]                               # closing bracket
              |,                                # comma
              |\b(?<!')(in|then|else|of)\b(?!') # keyword
              |(\#|@)-\}                        # End of annotation block (Liquidjuvix or pragma)
              |                                 # symbolic keyword except (->)
                (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']])
                (?:
                   (\\|λ)
                  |(<-|←)
                  |(=)
                  |(-<|↢)
                  |(-<<|⤛)
                )
                ([(),;\[\]`{}_"']|[^\p{S}\p{P}])
              # Indentation 
              |(?=\}|;)      # Explicit indentation
              |$             # End of line
            )
        patterns:
          - include: '#type_signature'
  type_variable:
    match: '\b(?<!'')(?!(?:forall|deriving)\b(?!''))[\p{Ll}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'']*'
    name: variable.other.generic-type.juvix
  type_constructor:
    patterns:
      # Type starting with a capital letter (optional promotion & qualification)
      - match: >-
          (?x)
            # Optional promotion tick
              (')?
            # Optional qualified name
              ((?:\b[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*\.)*)
            # Type constructor proper
              (\b[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)
        captures:
          '1': {name: keyword.operator.promotion.juvix}
          '2': {name: entity.name.namespace.juvix}
          '3': {name: storage.type.juvix}
      # Prefix form of a type operator (optional promotion & qualification)
      - match: >-
          (?x)
            # Optional promotion tick
              (')?
            # Opening parenthesis
              (\()\s*
            # Optional qualified name
              ((?:[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*\.)*)
            # Type operator proper
              ([\p{S}\p{P}&&[^(),;\[\]`{}_"']]+)
            # Closing parenthesis
              \s*(\))
        captures:
          '1': {name: keyword.operator.promotion.juvix}
          '2': {name: punctuation.paren.juvix}
          '3': {name: entity.name.namespace.juvix}
          '4': {name: storage.type.operator.juvix }
          '5': {name: punctuation.paren.juvix}
  overloaded_label:
    patterns:
      # See https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0170-unrestricted-overloadedlabels.rst
      - match: >-
          (?x) 
            (?<![\p{Ll}_\p{Lu}\p{Lt}\p{Nd}\p{S}\p{P}&&[^(,;\[`{]]) # Disallow closing characters
            (\#)
              (?:
              # String
              ("(?:\\"|[^"])*")
              # Sequence of allowed label identifiers
              |[\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'\.]+
              )
        captures:
          '1': {name: keyword.operator.prefix.hash.juvix}
          '2':
            patterns:
              - include: '#string_literal'
        name: entity.name.label.juvix
  reserved_symbol:
    patterns:
      # Fully reserved symbols,
      # not including '::' (special treatment as it starts type highlighting),
      # nor '=>' (it highlights its precedent as a type).
      - match: >-
          (?x)
            (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"'']])
            (?:
               (\.\.)
              |(:)
              |(=)
              |(\\)     # λ not reserved as it is a letter
              |(\|)
              |(<-|←)
              |(->|→)
              |(-<|↢)
              |(-<<|⤛)
              |(>-|⤚)
              |(>>-|⤜)
              |(∀)
            )
            (?![\p{S}\p{P}&&[^(),;\[\]`{}_"'']])
        captures:
          '1': {name: keyword.operator.double-dot.juvix}
          '2': {name: keyword.operator.colon.juvix}
          '3': {name: keyword.operator.eq.juvix}
          '4': {name: keyword.operator.lambda.juvix}
          '5': {name: keyword.operator.pipe.juvix}
          '6': {name: keyword.operator.arrow.left.juvix}
          '7': {name: keyword.operator.arrow.juvix}
          '8': {name: keyword.operator.arrow.left.tail.juvix}
          '9': {name: keyword.operator.arrow.left.tail.double.juvix}
          '10': {name: keyword.operator.arrow.tail.juvix}
          '11': {name: keyword.operator.arrow.tail.double.juvix}
          '12': {name: keyword.other.forall.juvix}
      # Reserved postfix symbol: '#'
      # This allows users to specify highlighting of '#' dependent on theme,
      # as we are unfortunately unable to make a decision based on enabled extensions.
      - match: >-
          (?x)
            (?<=[\p{Ll}_\p{Lu}\p{Lt}\p{Nd}\p{S}\p{P}&&[^\#,;\[`{]]) # Require closing characters
            (\#+)
            (?![\p{Ll}_\p{Lu}\p{Lt}\p{Nd}\p{S}\p{P}&&[^),;\]`}]])   # Disallow opening character
        captures:
          '1': {name: keyword.operator.postfix.hash.juvix}
      # Reserved tight infix symbol: '@'
      - match: >-
          (?x)
            (?<=[\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'\)\}\]]) # Require closing characters
            (@)
            (?=[\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'\(\[\{]) # Require opening character
        captures:
          '1': {name: keyword.operator.infix.tight.at.juvix}
      # Reserved prefix symbols,
      # not including '@' (special treatment, as a type application starts type highlighting).
      - match: >-
          (?x)
            (?<![\p{Ll}_\p{Lu}\p{Lt}\p{Nd}\p{S}\p{P}&&[^(,;\[`{]])  # Disallow closing characters
            (?:(~)|(!)|(-)|(\$)|(\$\$))
            (?=[\p{Ll}_'\p{Lu}\p{Lt}\p{Nd}\(\{\[]) # Require opening character (non operator symbol)
        captures:
          '1': {name: keyword.operator.prefix.tilde.juvix}
          '2': {name: keyword.operator.prefix.bang.juvix}
          '3': {name: keyword.operator.prefix.minus.juvix}
          '4': {name: keyword.operator.prefix.dollar.juvix}
          '5': {name: keyword.operator.prefix.double-dollar.juvix}
  type_operator:
    patterns:
      # Symbolic type operator (optional promotion & qualification)
      - match: >-
          (?x)
            # Optional promotion tick
              (?:(?<!')('))?
            # Optional qualified name
              ((?:\b[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*\.)*)
            # Type operator proper
              (?![#@]?-})(\#+|[\p{S}\p{P}&&[^(),;\[\]`{}_"']]+(?<!\#))
              #((?:[\p{S}\p{P}&&[^(),;\[\]`{}_"']&&[^#@]]|[@#](?!-}))+)
        captures:
          '1': {name: keyword.operator.promotion.juvix }
          '2': {name: entity.name.namespace.juvix }
          '3': {name: storage.type.operator.infix.juvix }
      # Infix form of alphanumeric type (optional promotion & qualification)
      - match: >-
          (?x)
            # Optional promotion tick
              (')?
            # Opening backtick
              (\`)
            # Optional qualified name
              ((?:[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*\.)*)
            # Type constructor proper
              ([\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)
            # Closing backtick
              (`)
        captures:
          '1': {name: keyword.operator.promotion.juvix}
          '2': {name: punctuation.backtick.juvix}
          '3': {name: entity.name.namespace.juvix}
          '4': {name: storage.type.infix.juvix}
          '5': {name: punctuation.backtick.juvix}
  forall:
    begin: '\b(?<!'')(forall|∀)\b(?!'')'
    end: '(\.)|(->|→)'
    beginCaptures: 
      '1': {name: keyword.other.forall.juvix}
    endCaptures:
      '1': {name: keyword.operator.period.juvix}
      '2': {name: keyword.operator.arrow.juvix}
    patterns:
      - include: '#comment_like'
      - include: '#type_variable'
      - include: '#type_signature'
  string_literal:
    begin: '"'
    beginCaptures:
      '0': {name: punctuation.definition.string.begin.juvix}
    end: '"'
    endCaptures:
      '0': {name: punctuation.definition.string.end.juvix}
    name: string.quoted.double.juvix
    patterns:
      - match: '\\(NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\"''\&])'
        name: constant.character.escape.juvix
      - match: '\\o[0-7]+|\\x[0-9A-Fa-f]+|\\[0-9]+'
        name: constant.character.escape.octal.juvix
      - match: '\\\^[A-Z@\[\]\\\^_]'
        name: constant.character.escape.control.juvix
      - begin: \\\s
        beginCaptures:
          '0': {name: constant.character.escape.begin.juvix}
        end: \\
        endCaptures:
          '0': {name: constant.character.escape.end.juvix}
        patterns:
          - match: \S+
            name: invalid.illegal.character-not-allowed-here.juvix
  char_literal:
    captures:
      '1': {name: punctuation.definition.string.begin.juvix}
      '2': {name: constant.character.escape.juvix}
      '3': {name: constant.character.escape.octal.juvix}
      '4': {name: constant.character.escape.hexadecimal.juvix}
      '5': {name: constant.character.escape.control.juvix}
      '6': {name: punctuation.definition.string.end.juvix}
    match: |
      (?x)
        (?<![\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'])
        (')
        (?:
          [\ -\[\]-~]                         # Basic Char
        | (\\(?:NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE
             |DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS
             |US|SP|DEL|[abfnrtv\\\"'\\&]))   # Escapes
        | (\\o[0-7]+)                         # Octal Escapes
        | (\\x[0-9A-Fa-f]+)                   # Hexadecimal Escapes
        | (\\\^[A-Z@\[\]\\\^_])                 # Control Chars
        )
        (')
    name: string.quoted.single.juvix
  float_literals:
    comment: 'Floats are decimal or hexadecimal'
    match: >-
      (?x)
        \b(?<!')
        (?:  # Decimal
          ([0-9][_0-9]*\.[0-9][_0-9]*(?:[eE][-+]?[0-9][_0-9]*)?
          |[0-9][_0-9]*[eE][-+]?[0-9][_0-9]*
          )
        |    # Hexadecimal
          (0[xX]_*[0-9a-fA-F][_0-9a-fA-F]*\.[0-9a-fA-F][_0-9a-fA-F]*(?:[pP][-+]?[0-9][_0-9]*)?
          |0[xX]_*[0-9a-fA-F][_0-9a-fA-F]*[pP][-+]?[0-9][_0-9]*
          )
        )\b(?!')
    captures:
      '1': {name: constant.numeric.floating.decimal.juvix}
      '2': {name: constant.numeric.floating.hexadecimal.juvix}
  integer_literals:
    match: >-
      (?x)
        \b(?<!')
        (?:
          ([0-9][_0-9]*)                    # Decimal integer
        | (0[xX]_*[0-9a-fA-F][_0-9a-fA-F]*) # Hexadecimal integer
        | (0[oO]_*[0-7][_0-7]*)             # Octal integer
        | (0[bB]_*[01][_01]*)               # Binary integer
        )
        \b(?!')
    captures:
      '1': {name: constant.numeric.integral.decimal.juvix}
      '2': {name: constant.numeric.integral.hexadecimal.juvix}
      '3': {name: constant.numeric.integral.octal.juvix}
      '4': {name: constant.numeric.integral.binary.juvix}
  numeric_literals:
    patterns:
      # Need to try to parse floating literals first,
      # to avoid having leftover dots.
      - include: '#float_literals'
      - include: '#integer_literals'
  ffi:
    begin: '^(\s*)(foreign)\s+(import|export)\s+'
    beginCaptures:
      '2': {name: keyword.other.foreign.juvix}
      '3': {name: "keyword.other.$3.juvix"}
    name: meta.$3.foreign.juvix
    end: |
      (?x) # Detect end of FFI block by decreasing indentation:
        (?=\}|;)       # Explicit indentation
        |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
            \1\s+\S    # - more indented, or
          | \s*        # - starts with whitespace, followed by:
            (?: $      #   - the end of the line (i.e. empty line), or
            |\{-[^@]   #   - the start of a block comment, or
            |--+       #   - the start of a single-line comment.
               (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                       # The double dash may not be followed by other operator characters
                       # (then it would be an operator, not a comment)
          )
    patterns:
      - include: '#comment_like'
      - match: '\b(?<!'')(ccall|cplusplus|dotnet|jvm|stdcall|prim|capi)\s+'
        captures:
          '1': {name: "keyword.other.calling-convention.$1.juvix"}
      - begin: '(?=")|(?=\b(?<!'')([\p{Ll}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'']*)\b(?!''))'
        end: '(?=(::|∷)(?![\p{S}\p{P}&&[^(),;\[\]`{}_"'']]))'
        patterns:
          # safe/unsafe/interruptible keywords,
          # but we must take care to still allow a function named "safe" without such a keyword
          # for instance:
          #
          # foreign import ccall safe foo :: ...
          #                      ^^^^ keyword
          #
          # foreign import ccall safe :: ...
          #                      ^^^^ not a keyword
          - include: '#comment_like'
          - match: |
              (?x)
                \b(?<!')(safe|unsafe|interruptible)\b(?!')
                \s*
                ("(?:\\"|[^"])*")?
                \s*
                (?:
                  (?:\b(?<!'')([\p{Ll}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)\b(?!'))
                 |(?:\(\s*(?!--+\))([\p{S}\p{P}&&[^(),;\[\]`{}_"']]+)\s*\))
                )
            captures:
              '1': {name: "keyword.other.safety.$1.juvix"}
              '2': 
                name: entity.name.foreign.juvix
                patterns:
                  - include: '#string_literal'
              '3': {name: entity.name.function.juvix}
              '4': {name: entity.name.function.infix.juvix}
          # Assume that if there is no function name on this line, it will appear on the next line
          - match: |
              (?x)
                \b(?<!')(safe|unsafe|interruptible)\b(?!')
                \s*
                ("(?:\\"|[^"])*")?
                \s*$
            captures:
              '1': {name: "keyword.other.safety.$1.juvix"}
              '2': 
                name: entity.name.foreign.juvix
                patterns:
                  - include: '#string_literal'
          - match: >-
              (?x)
                "(?:\\"|[^"])*"
            captures:
              '0': 
                name: entity.name.foreign.juvix
                patterns:
                  - include: '#string_literal'
          - match: |
              (?x)
                 (?:\b(?<!'')([\p{Ll}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)\b(?!'))
                |(?:(\()\s*(?!--+\))([\p{S}\p{P}&&[^(),;\[\]`{}_"']]+)\s*(\)))
            captures:
              '1': {name: entity.name.function.juvix}
              '2': {name: punctuation.paren.juvix}
              '3': {name: entity.name.function.infix.juvix}
              '4': {name: punctuation.paren.juvix}
      - include: '#double_colon'
      - include: '#type_signature'
  inline_phase:
    begin: '\['
    beginCaptures:
      '0': {name: punctuation.bracket.juvix}
    end: '\]'
    endCaptures:
      '0': {name: punctuation.bracket.juvix}
    name: meta.inlining-phase.juvix
    patterns:
      - match: '~'
        name: punctuation.tilde.juvix
      - include: '#integer_literals'
      - match: '\w*'
        name: invalid
  quasi_quote:
    patterns:
      - begin: >-
          (?x)
            (\[)
            (e|d|p)?
            (\|\|?)
        beginCaptures:
          '1': {name: keyword.operator.quasi-quotation.begin.juvix}
          '2': {name: entity.name.quasi-quoter.juvix}
          '3': {name: keyword.operator.quasi-quotation.begin.juvix}
        end: '\3\]'
        endCaptures:
          '0': {name: keyword.operator.quasi-quotation.end.juvix}
        name: meta.quasi-quotation.juvix
        patterns:
          - include: '$self'
      - begin: >-
          (?x)
            (\[)
            (t)
            (\|\|?)
        beginCaptures:
          '1': {name: keyword.operator.quasi-quotation.begin.juvix}
          '2': {name: entity.name.quasi-quoter.juvix}
          '3': {name: keyword.operator.quasi-quotation.begin.juvix}
        end: '\3\]'
        endCaptures:
          '0': {name: keyword.operator.quasi-quotation.end.juvix}
        name: meta.quasi-quotation.juvix
        patterns:
          - include: '#type_signature'
      - begin: >-
          (?x)
            (\[)
            (?:(\$\$)|(\$))?
            ((?:[^\s\p{S}\p{P}]|[\.'_])*)
            (\|\|?)
        beginCaptures:
          '1': {name: keyword.operator.quasi-quotation.begin.juvix}
          '2': {name: keyword.operator.prefix.double-dollar.juvix}
          '3': {name: keyword.operator.prefix.dollar.juvix}
          '4':
            patterns:
              - include: '#qualifier'
            name: entity.name.quasi-quoter.juvix
          '5': {name: keyword.operator.quasi-quotation.begin.juvix}
        end: '\5\]'
        endCaptures:
          '0': {name: keyword.operator.quasi-quotation.end.juvix}
        name: meta.quasi-quotation.juvix
scopeName: source.juvix
uuid: 5C034675-1F6D-497E-8073-369D37E2FD7D
