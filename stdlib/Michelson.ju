mod Prelude.Michelson where

open Prelude

-- datatypes
sig option : ty -> ty
let option = %Michelson.option

sig list : ty -> ty
let list = %Michelson.list

sig set : ty -> ty
let set = %Michelson.set

-- sig operation : ty -> ty
-- let operation = %Michelson.operation

-- sig contract : ty -> ty
-- let contract = %Michelson.contract

sig pair : ty -> ty
let pair = %Michelson.pair

-- sig either : ty -> ty
-- let either = %Michelson.either

sig map-ty : ty -> ty
let map-ty = %Michelson.map

sig big-map : ty -> ty
let big-map = %Michelson.big-map


-- primitive types
sig key : ty
let key = %Michelson.key

sig unit-t : ty
let unit-t = %Michelson.unit-t

sig signature : ty
let signature = %Michelson.signature

sig chain-id : ty
let chain-id = %Michelson.chain-id

sig int : ty
let int = %Michelson.int

sig nat : ty
let nat = %Michelson.nat

sig string : ty
let string = %Michelson.string

sig bytes : ty
let bytes = %Michelson.bytes

sig mutez : ty
let mutez = %Michelson.mutez

sig bool : ty
let bool = %Michelson.bool

sig key-hash : ty
let key-hash = %Michelson.key-hash

sig timestamp : ty
let timestamp = %Michelson.timestamp

sig address : ty
let address = %Michelson.address


-- arithmetic functions
sig add : (x : ty) -> x -> x -> x
let add = %Michelson.add

sig mul : (x : ty) -> x -> x -> x
let mul = %Michelson.mul

sig sub : (x : ty) -> x -> x -> x
let sub = %Michelson.sub

sig div : (x : ty) -> x -> x -> x
let div = %Michelson.div

sig abs : (x : ty) -> x -> x -> x
let abs = %Michelson.abs

-- boolean functions
sig and% : (x : ty) -> x -> x -> x
let and% = %Michelson.and

sig or : (x : ty) -> x -> x -> x
let or = %Michelson.or

sig xor : (x : ty) -> x -> x -> x
let xor = %Michelson.xor

-- sig not : (x : ty) -> x -> x -> x
-- let not = %Michelson.not

sig compare : (x : ty) -> x -> x -> int
let compare = %Michelson.compare

sig if2 : (x : ty) -> bool -> x -> x -> x
let if2 = %Michelson.if-builtin

-- other functions
sig now : timestamp
let now = %Michelson.now

sig amount : (x : ty) -> x -> unit-t
let amount = %Michelson.amount

sig balance : mutez
let balance = %Michelson.balance

sig sha256 : bytes -> bytes
let sha256 = %Michelson.sha256

sig sha512 : bytes -> bytes
let sha512 = %Michelson.sha512

sig blake2b : bytes -> bytes
let blake2b = %Michelson.blake2b

sig source : address
let source = %Michelson.source

sig sender : address
let sender = %Michelson.sender

-- sig implicit-account : operation
-- let implicit-account = %Michelson.implicit-account

-- sig create-contract : operation
-- let create-contract = %Michelson.create-contract

-- sig address-to-contract : (param : ty) -> address -> contract param
-- let address-to-contract = %Michelson.address-to-contract

sig transfer-tokens : (param : ty) -> param -> mutez -> contract param -> operation
let transfer-tokens = %Michelson.transfer-tokens

sig set-delegate : address -> unit-t
let set-delegate = %Michelson.set-delegate

sig none : either unit-t a
let none = %Michelson.none

sig some : b -> either a b
let some = %Michelson.some

sig left : a -> either a b
let left = %Michelson.left

sig right : b -> either a b
let right = %Michelson.right

sig nil : list a
let nil = %Michelson.nil

sig cons : a -> list a
let cons = %Michelson.cons

sig cons-pair : a -> b -> pair a b
let cons-pair = %Michelson.cons-pair

sig car : pair a b -> a
let car = %Michelson.car

sig cdr : pair a b -> b
let cdr = %Michelson.cdr

sig size : list a -> int
let size = %Michelson.size

sig empty-set : set a
let empty-set = %Michelson.empty-set

sig empty-map : map a
let empty-map = %Michelson.empty-map

sig empty-big-map : big-map a
let empty-big-map = %Michelson.empty-big-map

sig map : (x : ty) -> (a -> b) -> x a -> x b
let map = %Michelson.map

sig update : (x : ty) -> key -> a -> x a -> unit-t
let update = %Michelson.update

-- sig iter : (x : ty) -> (a -> b) -> (b -> unit-t)
-- let iter = %Michelson.iter

sig get : (x: ty) -> key -> x a -> a
let get = %Michelson.get

sig hash-key : key -> key-hash
let hash-key = %Michelson.hash-key

sig mem : (x : ty) -> x -> bool
let mem = %Michelson.mem

sig concat : (x : ty) -> x -> x -> x
let concat = %Michelson.concat

sig slice : nat -> string -> option string
let slice = %Michelson.slice

sig lsl : nat -> nat -> nat
let lsl = %Michelson.lsl

sig lsr : nat -> nat -> nat
let lsr = %Michelson.lsl

sig fail-with : (x : ty) -> (y : ty) -> x -> y
let fail-with = %Michelson.fail-with

sig self : (x : ty) -> x
let self = %Michelson.self

sig unit : unit-t
let unit = %Michelson.unit