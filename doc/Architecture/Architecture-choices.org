* Architecture Choices
This document outlines various architectural choices throughout the
code base that may seem non-obvious.
** Usage of the Capability Library
- Historically Haskell is written with the =mtl= library. This library
  allows =Monads= to stack ontop of each other in a linear fashion. This
  is very nice, as it allows the pluming of how each layer interacts to
  be abstracted away. However these advancements do not come without a
  cost which are outlined below
  + _Downsides with MTL_
    * [[https://www.fpcomplete.com/blog/2017/06/readert-design-pattern][ReaderT design pattern]].
      - This means that as our monad stacks grow and our state monad
        fails to deal with concurrent programming, we will have to
        rewrite the backend to use =IO= over a single =Reader Monad=.
    * Explicit heavy use of lenses
      - Due to every state being forced into a single reader monad,
        and not wanting to couple every function with everything in
        the reader environment, lenses with views into the struct
        itself must be used instead.
        + [[https://github.com/mariari/Tiger-Compiler/blob/master/src/App/Environment.hs][Definition Here]]
        + [[https://github.com/mariari/Tiger-Compiler/blob/master/src/Semantic/Translate.hs#L204][Useage here]]
    * Inefficiencies in execution
      - Due to =MTL= Working as a list of effects rather than a set of
        effects, the more layers one adds to one's =MTL= stack, the
        slower the execution speed is.
      - Even worse, [[https://blog.infinitenegativeutility.com/2016/7/writer-monads-and-space-leaks][is that the writer monad always leaks sapce]] and
        thus should be avoided
- Solving These Issues with capability
** Org mode documentation
** De-Bruijin Indices
** Parameterisation of the backend
