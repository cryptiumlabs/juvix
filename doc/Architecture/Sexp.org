* Generation
** Top Level
*** Let
1. basic
   - input
     #+begin_src haskell
       let foo x
         | x == 2 = 3 + 4 + x
         | else   = x + 2
     #+end_src
   - output
     #+begin_src lisp
       (:defun foo (x)
         (:cond
           ((:infix == x 2) (:infix + 3 (:infix + 4 x)))
           (else            (:infix + x 2))))
     #+end_src
*** Sig
1. basic
   - input
     #+begin_src haskell
       sig foo : int -> int -> int
     #+end_src
   - output
     #+begin_src lisp
       (:defsig foo (:infix -> int (:infix -> int int)))
     #+end_src
2. usage
   - input
     #+begin_src haskell
       sig foo 0 : int -> int -> int
     #+end_src
   - output
     #+begin_src lisp
       (:defsig foo (:usage 0 (:infix -> int (:infix -> int int))))
     #+end_src
   - This form is a bit odd, ideally it'd mimic the [[Top Level Types]]
     version like
     #+begin_src lisp
       (:defsig (foo :usage 0) (:infix -> int (:infix -> int int)))
     #+end_src
     + However for now I think it's fine... Though this is a place for
       improvement for the future
*** Types
1. record
   - input
     #+begin_src haskell
       type foo x y z =
         { y-axis : y
         , x-axis : x
         , z-axis : z }
     #+end_src
   - output
     #+begin_src lisp
       (type foo (x y z)
          (:record
            y-axis y
            x-axis x
            z-axis z))
     #+end_src
2. first sum
   - input
     #+begin_src haskell
       type foo x y z =
         | Foo {y-axis : y, x-axis : x, z-axis : z}
         | Bar (var1 : x) (var2 : y)
         | Car : hd : x -> cdr : foo y -> foo x y z
     #+end_src
   - output
     #+begin_src lisp
       (type foo (x y z)
         (Foo (:record y-axis y x-axis x z-axis z))
         (Bar (:paren (:infix : var1 x))
              (:paren (:infix : var2 y)))
         (Car (:arrow
               (:infix : hd
                       (:infix -> x
                               (:infix : cdr
                                       (:infix -> (foo y) (foo x y z))))))))
     #+end_src
3. Signature
   - input
     #+begin_src haskell
       type foo x y z : typ -> typ -> typ = Foo a b c
     #+end_src
   - output
     #+begin_src lisp
       (type (foo :type (:infix -> typ (:infix -> typ typ))) (x y z)
          (Foo a b c))
     #+end_src
*** Decalration
1. basic
   - input
     #+begin_src haskell
       declare infixl foo 3
     #+end_src
   - output
     #+begin_src lisp
       (declare infixl foo 3)
     #+end_src
*** Module
1. basic
   - input
     #+begin_src haskell
       mod foo =
         let bar = 3
         type zar = Boo
       end
     #+end_src
   - output
     #+begin_src lisp
       (:defmodule foo ()
         (:defun bar () 3)
         (type zar () (Boo)))
     #+end_src
** Expression
*** Let
1. basic
   - input
     #+begin_src haskell
       let foo y =
         let fi = 3 in
         fi
     #+end_src
   - output
     #+begin_src lisp
       (:defun foo (y)
         (let fi () 3
           fi))
     #+end_src
2. arguments
   - input
     #+begin_src haskell
       let foo y =
         let fi x = 3 + x in
         fi y
     #+end_src
   - output
     #+begin_src lisp
       (:defun foo (y)
         (let fi (x) (:infix + 3 x)
           (fi y)))
     #+end_src
*** Tuples
1. basic
   - input
     #+begin_src haskell
       let foo = (1,2,3)
     #+end_src
   - output
     #+begin_src lisp
       (:defun foo () (:tuple 1 2 3))
     #+end_src
*** Lists
1. basic
   - input
     #+begin_src haskell
       let foo = [1,2,3,4]
     #+end_src
   - output
     #+begin_src lisp
       (:defun foo () (:list 1 2 3 4))
     #+end_src
*** Records
1. basic
   - input
     #+begin_src haskell
       let foo = {a, b = 2}
     #+end_src
   - output
     #+begin_src lisp
       (:defun foo () (:record (a) (b 2)))
     #+end_src
*** Do
1. basic
   - input
     #+begin_src haskell
       let foo xs =
         a <- xs;
         more-comp;
         pure a
     #+end_src
   - output
     #+begin_src lisp
       (:defun foo (xs)
         (:do (%<- a xs)
              more-comp
              (pure a)))
     #+end_src
*** Lambda
1. basic
   - input
     #+begin_src haskell
       let foo y =
         \x -> x + y
     #+end_src
   - output
     #+begin_src lisp
       (:defun foo (y)
         (:lambda (x) (:infix + x y)))
     #+end_src
*** Open
1. basic
   - input
     #+begin_src haskell
       let foo y =
         open Prelude in
         x + y
     #+end_src
   - output
     #+begin_src lisp
       (:defun foo (y)
         (:open-in Prelude
            (:infix + x y)))
     #+end_src
*** Parens
1. basic
   - input
     #+begin_src haskell
       let foo y = (y + 3) * 9
     #+end_src
   - output
     #+begin_src lisp
       (:defun foo (y)
         (:infix * (:paren (:infix + y 3)) 9))
     #+end_src
*** Block
1. basic
   - input
     #+begin_src haskell
       let foo y = 3 * begin y + y end
     #+end_src
   - output
     #+begin_src lisp
       (:defun foo (y)
         (:infix * 3 (:progn (:infix + y y))))
     #+end_src
*** Primitive
1. basic
   - input
     #+begin_src haskell
       let add = %Michelson.add
     #+end_src
   - output
     #+begin_src lisp
       (:defun add ()
         (:primitive Michelson.add))
     #+end_src
*** Cond
1. basic
   - input
     #+begin_src haskell
       let add x =
         if | x == 3 = 1
            | x == 4 = 5
            | else   = 0
     #+end_src
   - output
     #+begin_src lisp
       (:defun add (x)
         (:cond ((:infix == x 3) 1)
                ((:infix == x 4) 5)
                (else            0)))
     #+end_src
* Notes
** Design Principles
** On Verbosity
** On Forms
** Inconsistencies
* Template
1. basic
   - input
     #+begin_src haskell
     #+end_src
   - output
     #+begin_src lisp
     #+end_src
