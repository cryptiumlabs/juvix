* Generation
** Let Top Level
1. basic
   - input
     #+begin_src haskell
       let foo x
         | x == 2 = 3 + 4 + x
         | else   = x + 2
     #+end_src
   - output
     #+begin_src lisp
       (:defun foo (x)
         (:cond
           ((:infix == x 2) (:infix + 3 (:infix + 4 x)))
           (else            (:infix + x 2))))
     #+end_src
** Top Level Sig
1. basic
   - input
     #+begin_src haskell
       sig foo : int -> int -> int
     #+end_src
   - output
     #+begin_src lisp
       (:defsig foo (:infix -> int (:infix -> int int)))
     #+end_src
2. usage
   - input
     #+begin_src haskell
       sig foo 0 : int -> int -> int
     #+end_src
   - output
     #+begin_src lisp
       (:defsig foo (:usage 0 (:infix -> int (:infix -> int int))))
     #+end_src
   - This form is a bit odd, ideally it'd mimic the [[Top Level Types]]
     version like
     #+begin_src lisp
       (:defsig (foo :usage 0) (:infix -> int (:infix -> int int)))
     #+end_src
     + However for now I think it's fine... Though this is a place for
       improvement for the future
** Top Level Types
1. record
   - input
     #+begin_src haskell
       type foo x y z =
         { y-axis : y
         , x-axis : x
         , z-axis : z }
     #+end_src
   - output
     #+begin_src lisp
       (type foo (x y z)
          (:record
            y-axis y
            x-axis x
            z-axis z))
     #+end_src
2. first sum
   - input
     #+begin_src haskell
       type foo x y z =
         | Foo {y-axis : y, x-axis : x, z-axis : z}
         | Bar (var1 : x) (var2 : y)
         | Car : hd : x -> cdr : foo y -> foo x y z
     #+end_src
   - output
     #+begin_src lisp
       (type foo (x y z)
         (Foo (:record y-axis y x-axis x z-axis z))
         (Bar (:paren (:infix : var1 x))
              (:paren (:infix : var2 y)))
         (Car (:arrow
               (:infix : hd
                       (:infix -> x
                               (:infix : cdr
                                       (:infix -> (foo y) (foo x y z))))))))
     #+end_src
* Notes

** Design Principles
** On Verbosity
** On Forms
** Inconsistencies
* Template
1. basic
   - input
     #+begin_src haskell
     #+end_src
   - output
     #+begin_src lisp
     #+end_src
