* Generation
** Top Level
*** Let
1. basic
   - input
     #+begin_src haskell
       let foo x
         | x == 2 = 3 + 4 + x
         | else   = x + 2
     #+end_src
   - output
     #+begin_src lisp
       (:defun foo (x)
         (:cond
           ((:infix == x 2) (:infix + 3 (:infix + 4 x)))
           (else            (:infix + x 2))))
     #+end_src
*** Sig 
1. basic
   - input
     #+begin_src haskell
       sig foo : int -> int -> int
     #+end_src
   - output
     #+begin_src lisp
       (:defsig foo (:infix -> int (:infix -> int int)))
     #+end_src
2. usage
   - input
     #+begin_src haskell
       sig foo 0 : int -> int -> int
     #+end_src
   - output
     #+begin_src lisp
       (:defsig foo (:usage 0 (:infix -> int (:infix -> int int))))
     #+end_src
   - This form is a bit odd, ideally it'd mimic the [[Top Level Types]]
     version like
     #+begin_src lisp
       (:defsig (foo :usage 0) (:infix -> int (:infix -> int int)))
     #+end_src
     + However for now I think it's fine... Though this is a place for
       improvement for the future
*** Types
1. record
   - input
     #+begin_src haskell
       type foo x y z =
         { y-axis : y
         , x-axis : x
         , z-axis : z }
     #+end_src
   - output
     #+begin_src lisp
       (type foo (x y z)
          (:record
            y-axis y
            x-axis x
            z-axis z))
     #+end_src
2. first sum
   - input
     #+begin_src haskell
       type foo x y z =
         | Foo {y-axis : y, x-axis : x, z-axis : z}
         | Bar (var1 : x) (var2 : y)
         | Car : hd : x -> cdr : foo y -> foo x y z
     #+end_src
   - output
     #+begin_src lisp
       (type foo (x y z)
         (Foo (:record y-axis y x-axis x z-axis z))
         (Bar (:paren (:infix : var1 x))
              (:paren (:infix : var2 y)))
         (Car (:arrow
               (:infix : hd
                       (:infix -> x
                               (:infix : cdr
                                       (:infix -> (foo y) (foo x y z))))))))
     #+end_src
3. Signature
   - input
     #+begin_src haskell
       type foo x y z : typ -> typ -> typ = Foo a b c
     #+end_src
   - output
     #+begin_src lisp
       (type (foo :type (:infix -> typ (:infix -> typ typ))) (x y z)
          (Foo a b c))
     #+end_src
*** Decalration
1. basic
   - input
     #+begin_src haskell
       declare infixl foo 3
     #+end_src
   - output
     #+begin_src lisp
       (declare infixl foo 3)
     #+end_src
*** Module
1. basic
   - input
     #+begin_src haskell
       mod foo =
         let bar = 3
         type zar = Boo
       end
     #+end_src
   - output
     #+begin_src lisp
       (:defmodule foo ()
         (:defun bar () 3)
         (type zar () (Boo)))
     #+end_src
** Expression


* Notes

** Design Principles
** On Verbosity
** On Forms
** Inconsistencies
* Template
1. basic
   - input
     #+begin_src haskell
     #+end_src
   - output
     #+begin_src lisp
     #+end_src
