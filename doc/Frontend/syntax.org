* Syntax
#+BEGIN_SRC bnf
  top-level ::= <type>
              | <module-open>
              | <type-class>
              | <type-class-instance>
              ; These four last, due to lack of words before
              | <module-signature>
              | <module>
              | <module-open>
              | <signature>
              | <function>

  ;;;; Functions ======================================================

  function ::= <name> <args>+ = <expression>
             | <name> <args>+ <cond-logic>*

  ;; Match-logic could just be a name, and so is thus fine
  args ::= <match-logic>

  ;; if we only have usage in arrows, we should allow a way to have
  ;; usage information of variables as well!
  signature ::= <name>         :                 <arrow-type>
              | <name>         : <type-name> =\> <arrow-type>
              | <name> <usage> :                 <arrow-type>
              | <name> <usage> : <type-name> =\> <arrow-type>

  ;;;; Types ==========================================================

  type ::= <data-declaration>
         | <type-declaration>
         | <alias-declaration>

  ;; Should we let there be a refinement in adt type declaration?
  data-declaration  ::= type <non-capital-name> : <arrow-type> = <adt>
                      | type <non-capital-name>                = <adt>

  type-declaration  ::= type <non-capital-name> = <name> <type-refine>
  alias-declaration ::= type <non-capital-name> = <type-refine>

  adt ::= <sum>*
        | <product>


  ;; | is special in bnf
  sum ::= \| <name>
        | \| <name> <product>

  product ::= { <name-type-semi>+ <name-type>* } <type-name>
            | { <name-type-semi>* }              <type-name>
            | { <name-type-semi>+ <name-type>* }
            | { <name-type-semi>* }
            | <arrow-type>

  name-type      ::= <name> <type-signature>
  name-type-semi ::= <name-type> <semi>

  ;; should we move ()'s somewhere else?
  arrow-type ::= <type-refine>
               | <name> : <type-refine> <arrow> <arrow-type>
               | <type-refine>          <arrow> <arrow-type>
               | ( <arrow-type> )

  type-signature ::= : <arrow-type>

  ;; { } here are a refinement type!
  type-refine ::= <type-name> { <expression> }
                | <type-name>

  ;;;; Arrows =========================================================


  arrow ::= -\> ; Ï‰ usage by default? This should be the most common arrow
          | -o  ; linear usage
          | -|  ; ??? some kind of usage
          | -<usage>-\>
          | --<usage>--\> ; maybe remove this one?

  ;;; Modules ========================================================

  ;; For all intensive purposes, modules are the same as values, just with
  ;; top level expressions, and a minimal amount of sugar

  ;; This doubles as our import
  module-open ::= open <module-name>


  module-open-expression ::= open <module-name> in

  ;; We are going to make modules a bit more interesting, syntax wise
  ;; imagine modules were functions with capital name to delineate
  ;; thus module signatures have the same signature look as functions

  ;; Interestingly enough module "functors" can take more than just modules
  ;; they can take any value, however for examples, we will encourage the use
  ;; of taking (and thus parameterizing) modules

  module ::= <name> <args>+ = <top-level>
           | <name> <args>+ <cond-top>*

  cond-top ::= \| <expression> = <expression>
  ;;;; Types Classes ==================================================

  ;; Need end if we are indent sensitive!
  type-class ::= class <type-name> where
               | class <type-name> =\> <type-name> where

  ;; Need end if we are indent sensitive!
  type-class-instance ::= instance <type-name> where

  ;;;; Expressions ====================================================

  ;; See comments about which to keep and which to maybe remove
  expression ::= <match>
               | <if>
               | <cond>
               | <record-access>
               | <module-lookup>
               | <let>
               | <module-open-expression>
               | <where>
               | <string>
               | <number>

  usage ::= <expression>

  record-access ::= <name>.<name>

  module-lookup ::= <module-name>.<name>


  ;;; Matching ===================================

  match ::= case <expression> of <match-l>*

  match-l ::= \| <match-logic>

  match-logic ::= <constructor-name>         <match-logic>+
                | <name>                     <match-logic>+
                | <name> @ <match-logic>     <match-logic>+
                | <name> @ ( <match-logic> ) <match-logic>+
                | <record-match>

  record-match ::= { <name-set>* }


  name-set ::= <name> = <name>
             | <name>

  ;; we should remove either if or cond!?
  if   ::= if   <cond-logic>*
  cond ::= cond <cond-logic>*


  ;;; Bindings ===================================

  ;; Due to trying to be less indent sensitive,
  ;; we only look for the in alternative,
  ;; is that we only have a single binding per let.
  let ::= let <binding>* in <expression>

  ;; Does this even make sense to have?
  ;; Juvix is not lazy, how is order determined?
  ;; is it only for pure values???
  where ::= <expression> where <bindings>*

  binding ::= <match-logic> = <expression>


  ;; note it's fine to use |,
  ;; as matches have to be a pattern,
  ;; and thus not some expression

  ;; note in stdlib else and otherwise will both be true

  cond-logic ::= \| <expression> = <expression>

  ;;; Numbers ====================================

  number ::= <digits>*.<digits>*
           | <digits>*<exp>
           | <digits>*.<digits>*<exp>


  digits ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9


  exp ::= e <digits>*
  ;;; Strings ====================================

  ;; Give nicer string syntax?
  string ::= " <escaped-string>+ "

  escaped-string ::= <ascii-no-quotes-no-backslash> <escaped-string>+
                   | \" <escaped-string>+
                   | \ <escaped-string>+

  ;;;; Misc ===========================================================
  ;; ; is comment in bnf
  semi             ::= \;
  name             ::= <ascii-non-reserved>
  non-capital-name ::= <ascii-no-capital>
  capital-name     ::= <ascii-capital>
  ;; may want m e or Map.t int string?
  type-name        ::= <name>
                     | <name> <type-name>
  module-name      ::= <name> ; enforce capital names?

  constructor-name ::= <capital-name-and-symbols>

  ascii-non-reserved ::=
  ascii-no-capital   ::=
  ascii-capital      ::=
#+END_SRC
