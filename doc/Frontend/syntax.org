* Syntax
#+BEGIN_SRC bnf
  top-level ::= <type>
              | <module-open>
              | <type-class>
              | <type-class-instance>
              ; These four last, due to lack of words before
              | <module-signature>
              | <module>
              | <signature>
              | <function>

  ;;; Functions ======================================================

  function ::= <non-capital-name> <args>+ = <expression>
             | <non-capital-name> <args>+ <cond-logic>*

  args ::= <name>
         | <match-logic>

  ;; if we only have usage in arrows, we should allow a way to have
  ;; usage information of variables as well!
  signature ::= <non-capital-name>         <type-signature>
              | <non-capital-name> <usage> <type-signature>

  ;;; Types ==========================================================

  type ::= <data-declaration>
         | <type-declaration>
         | <alias-declaration>

  ;; Should we let there be a refinement in adt type declaration?
  data-declaration  ::= type <non-capital-name> : <arrow-type> = <adt>
                      | type <non-capital-name>                = <adt>

  type-declaration  ::= type <non-capital-name> = <name> <type-refine>
  alias-declaration ::= type <non-capital-name> = <type-refine>

  adt ::= <sum>*
        | <product>


  ;; | is special in bnf
  sum ::= \| <name>
        | \| <name> <product>

  product ::= { <name-type-semi>+ <name-type>* } <type-name>
            | { <name-type-semi>* }              <type-name>
            | { <name-type-semi>+ <name-type>* }
            | { <name-type-semi>* }
            | <arrow-type>

  name-type      ::= <name> <type-signature>
  name-type-semi ::= <name-type> <semi>

  ;; should we move ()'s somewhere else?
  arrow-type ::= <type-refine>
               | <name> : <type-refine> <arrow> <arrow-type>
               | <type-refine>          <arrow> <arrow-type>
               | ( <arrow-type> )

  type-signature ::= : <arrow-type>

  ;; { } here are a refinement type!
  type-refine ::= <type-name> { <expression> }
                | <type-name>

  ;;; Arrows =========================================================


  arrow ::= -\> ; Ï‰ usage by default? This should be the most common arrow
          | -o  ; linear usage
          | -|  ; ??? some kind of usage
          | -<usage>-\>
          | --<usage>--\> ; maybe remove this one?

  ;;; Modules ========================================================

  ;; This doubles as our import
  module-open ::= open <module-name>

  ;; We are going to make modules a bit more interesting, syntax wise
  ;; imagine modules were functions with capital name to delineate
  ;; thus module signatures have the same signature look as functions
  ;; however the end of this signature is quite a bit different than normal
  ;; functions, Maybe has { }, maybe has end? I'm not really sure yet

  ;; Don't need end if we are indent sensitive!
  module ::= <module-name> <module-name>+ = <top-level>+ end

  ;;; Types Classes ==================================================

  ;; Need end if we are indent sensitive!
  type-class ::= class <type-name> where

  ;; Need end if we are indent sensitive!
  type-class-instance ::= instance <..> where

  ;;; Expressions ====================================================
  expression ::=

  usage ::= <expression>


  record-access ::= <name>.<name>

  module-lookup ::= <module-name>.<name>


  match ::= case <expression> of <match-logic>*

  match-logic ::=

  ;; we should remove either if or cond!?
  if   ::= if   <cond-logic>*
  cond ::= cond <cond-logic>*


  ;; note it's fine to use |, as matches have to be a pattern,
  ;; and thus not some expression
  cond-logic ::= \| <expression> = <expression>

  ;; note in stdlib else and otherwise will both be true

  ;;; Misc ===========================================================
  ;; ; is comment in bnf
  semi             ::= \;
  name             ::= <ascii-non-reserved>
  non-capital-name ::= <ascii-no-capital>
  capital-name     ::= <ascii-capital>
  ;; may want m e or Map.t int string?
  type-name        ::= <name>
                     | <name> <type-name>
  module-name      ::= <capital-name> ; enforce capital names?

  ascii-non-reserved ::=
  ascii-no-capital   ::=
  ascii-capital      ::=
#+END_SRC
