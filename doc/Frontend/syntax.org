* Syntax
#+BEGIN_SRC bnf
  top-level ::= <type>
              | <module-open>
              | <type-class>
              | <type-class-instance>
              ; These four last, due to lack of words before
              | <module-signature>
              | <module>
              | <module-open>
              | <signature>
              | <function>

  ;;;; Functions ======================================================

  function ::= <name> <args>+ = <expression>
             | <name> <args>+ <cond-logic>*

  ;; Match-logic could just be a name, and so is thus fine
  ;; # is for implicit
  ;; Should we have implicit pattern matching like here?
  args ::= <match-logic>
         | #<match-logic>

  ;; if we only have usage in arrows, we should allow a way to have
  ;; usage information of variables as well!
  signature ::= <name>         :                 <arrow-type>
              | <name>         : <type-name> =\> <arrow-type>
              | <name> <usage> :                 <arrow-type>
              | <name> <usage> : <type-name> =\> <arrow-type>

  ;;;; Types ==========================================================

  type ::= <data-declaration>
         | <type-declaration>
         | <alias-declaration>

  ;; Should we let there be a refinement in adt type declaration?
  ;; ? means it may or may not be there
  ;; it makes sense to have the number here, as it can't be confused with an
  ;; expression type
  data-declaration
    ::= type u#<usage>? <non-capital-name> <symbols>+ : <arrow-type> = <adt>
      | type u#<usage>? <non-capital-name> <symbols>+                = <adt>

  type-declaration
    ::= type u#<usage>? <non-capital-name> <symbols>+ = | <name> <type-refine>
  alias-declaration
    ::= type u#<usage>? <non-capital-name> <symbols>+ = <type-refine>

  adt ::= <sum>*
        | <product>


  ;; | is special in bnf
  sum ::= \| <name>
        | \| <name> <product>

  product ::= { <name-type-comma>+ <name-type>* } -\> <type-name>
            | { <name-type-comma>* }              -\> <type-name>
            | { <name-type-comma>+ <name-type>* }
            | { <name-type-comma>* }
            | <arrow-type>

  name-type      ::= <name> <type-signature>
                   | #<name> <type-signature>
  name-type-comma ::= <name-type> <comma>

  ;; should we move ()'s somewhere else?
  ;; # is implicit argument
  arrow-type ::= <type-refine>
               | <name>  : <type-refine>
               | <name>  : <type-refine> <arrow> <arrow-type>
               | #<name> : <type-refine> <arrow> <arrow-type>
               | <type-refine>           <arrow> <arrow-type>
               | ( <arrow-type> )

  type-signature ::= : <arrow-type>

  ;; { } here are a refinement type!
  type-refine ::= <type-name> { <expression> }
                | <type-name>

  ;;;; Arrows =========================================================


  arrow ::= -\> ; Ï‰ usage by default? This should be the most common arrow
          | -o  ; linear usage
          | -|  ; ??? some kind of usage
          | -<usage>-\>
          | --<usage>--\> ; maybe remove this one?

  ;;; Modules ========================================================

  ;; For all intensive purposes, modules are the same as values, just with
  ;; top level expressions, and a minimal amount of sugar

  ;; This doubles as our import
  module-open ::= open <module-name>


  module-open-expression ::= open <module-name> in

  ;; We are going to make modules a bit more interesting, syntax wise
  ;; imagine modules were functions with capital name to delineate
  ;; thus module signatures have the same signature look as functions

  ;; Interestingly enough module "functors" can take more than just modules
  ;; they can take any value, however for examples, we will encourage the use
  ;; of taking (and thus parameterizing) modules

  module ::= <name> <args>+ = <top-level>
           | <name> <args>+ <cond-top>*

  cond-top ::= \| <expression> = <expression>
  ;;;; Types Classes ==================================================

  ;; Need end if we are indent sensitive!
  type-class ::= class <type-name> where
               | class <type-name> =\> <type-name> where

  ;; Need end if we are indent sensitive!
  type-class-instance ::= instance <type-name> where

  ;;;; Expressions ====================================================

  ;; See comments about which to keep and which to maybe remove
  expression ::= <match>
               | <if>
               | <cond>
               | <record-access>
               | <module-lookup>
               | <let>
               | <module-open-expression>
               | <where>
               | <string>
               | <number>
               ; TODO
               | <symbol>
               | <prefix>
               | <infix>
               | <do>
               | <tuple>
               | <comments>
               | <parens>

  usage ::= <expression>

  record-access ::= <name>.<name>

  module-lookup ::= <module-name>.<name>


  ;;; Matching ===================================

  match ::= case <expression> of <match-l>*

  match-l ::= \| <match-logic> -\> <expression>

  match-logic ::= ( <match-logic'> )

  match-logic' ::= <constructor-name>         <match-logic>+
                 | <name>                     <match-logic>+
                 | <name> @ <match-logic>     <match-logic>+
                 | <name> @ ( <match-logic> ) <match-logic>+
                 | <name> @ <record-match>
                 | <record-match>

  record-match ::= { <name-set>* }


  name-set ::= <name> = <name>
             | <name>

  ;; we should remove either if or cond!?
  if   ::= if   <cond-logic>*
  cond ::= cond <cond-logic>*


  ;;; Bindings ===================================

  ;; Due to trying to be less indent sensitive,
  ;; we only look for the in alternative,
  ;; is that we only have a single binding per let.
  let ::= let <binding>* in <expression>

  ;; Does this even make sense to have?
  ;; Juvix is not lazy, how is order determined?
  ;; is it only for pure values???
  where ::= <expression> where <bindings>*

  binding ::= <match-logic> = <expression>


  ;; note it's fine to use |,
  ;; as matches have to be a pattern,
  ;; and thus not some expression

  ;; note in stdlib else and otherwise will both be true

  cond-logic ::= \| <expression> = <expression>

  ;;; Numbers ====================================

  number ::= <digits>*.<digits>*
           | <digits>*<exp>
           | <digits>*.<digits>*<exp>


  digits ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9


  exp ::= e <digits>*
  ;;; Strings ====================================

  ;; Give nicer string syntax?
  string ::= " <escaped-string>+ "

  escaped-string ::= <ascii-no-quotes-no-backslash> <escaped-string>+
                   | \" <escaped-string>+
                   | \ <escaped-string>+

  ;;; Universe ====================================

  ;; for now, set it up to what F* has, expand it later
  universe-expression ::= u#<name>
                       | u#<name> + u#<name>
                       | max u#<name>*

  ;;;; Misc ===========================================================
  ;; ; is comment in bnf
  comma            ::= ,
  semi             ::= \;
  name             ::= <ascii-non-reserved>
  non-capital-name ::= <ascii-no-capital>
  capital-name     ::= <ascii-capital>
  ;; may want m e or Map.t int string?
  type-name   ::= <name> <others-names>+
  other-names ::= <name>
                | <universe-expression>
                | ( <arrow-type> )
  module-name      ::= <name> ; enforce capital names?

  constructor-name ::= <capital-name-and-symbols>

  ascii-non-reserved ::=
  ascii-no-capital   ::=
  ascii-capital      ::=
#+END_SRC
