* Syntax Guide
This document is heavily inspired by the [[http://docs.idris-lang.org/en/latest/reference/syntax-guide.html][Idris syntax guide]].
** File Organization
A file contains zero or more [[Top Level Declarations]]

For example
#+BEGIN_SRC ocaml
  -- this is a function with a signature!
  sig foo : Natural
  let foo = 3

  -- this is a data type declaration
  type list a = Cons a (List a)
              | Nil

  -- this is a module declaration!
  mod Boo =
    let fi = 10
  end
#+END_SRC
** Comments
Comments are denoted by two dashes, =--=, and it and all characters up
until the end of the line are discarded

Example:
#+BEGIN_SRC ocaml
  -- This is a comment!
#+END_SRC
** Symbols
Symbols are used for any name declared in the Juvix programming
language. Symbols are broken into two categories, infix and prefix

Prefix symbols start with either an alpha character or an underscore,
which can be followed up by any alphanumeric character, underscores,
punctuation(?, !), or dashes.

#+BEGIN_SRC haskell

  -- a valid symbol
  hello-there

  -- another valid symbol
  _unused-symbol

  -- a valid predicate
  even?

  -- An important action
  foo!

  -- not a valid prefix symbol
  -foo
#+END_SRC

An infix symbol starts with all other symbols including punctuation
and dashes

#+BEGIN_SRC haskell
  -- This is a valid infix symbol

  !!

  -- this is also another valid infix symbol

  -<++

  -- this is not a valid infix symbol, but instead a comment of a -

  ---

  -- here is an arrow infix symbol

  ->
#+END_SRC

** Top Level Declarations
*** Functions

**** Signatures
**** Implicit Arguments
*** Types
*** Modules
*** Imports
one can import a module in two ways.

Either by opening them

#+BEGIN_SRC ocaml
  -- A valid open
  open Foo


  open Foo.Bar.Baz
#+END_SRC

or aliasing them with a let
#+BEGIN_SRC ocaml
  -- a valid module alias
  let F = Foo
#+END_SRC

** Expressions
*** Conditionals
**** If
If expressions have a non zero number of clauses. Each clause consists
of a boolean test, followed by a consequence.

Example:
#+BEGIN_SRC haskell
  -- this is a valid if expression!
  if | x == 3 -> 5
     | else   -> 6
  -- ^ test      ^ consequence

  -- this is also a valid a valid if expression
  if | x == 10     -> 25
     | positive? x -> x
     | negative? x -> abs x
     | else        -> 0
#+END_SRC

The =else= name is just an alias for =False=.
**** Case
Case expressions have a non zero number of clauses. Each clause
consists of a pattern, followed by a consequence.

A pattern works much like Haskell or Idris, in that one can
deconstruct on a record or a constructor. We also allow record punning
on matches.

Example:
#+BEGIN_SRC ocaml
  type tree a = Branch (tree a) a (tree a)
              | Leaf a
              | Empty


  -- an example with match!
  let func foo =
    case foo of
    | Branch left ele right ->
      func left + ele + func right
    | Leaf ele ->
      ele
    | Empty ->
      0


  -- This is the same function!
  let func (Branch left ele right) =
    func left + ele + func right
  let func (Leaf ele) =
    ele
  let func Empty =
    0


  type cords = {
    x : int,
    y : int
  }

  -- match on record

  sig origin? : cords -> boolean
  let origin? {x, y}
    | x == y && x == 0 = True
    | else             = False

  -- same function as origin
  sig origin2? : cords -> boolean
  let origin2? {x = origX, y = origY}
    | origX == origY && origX == 0 =
      True
    | else = False
#+END_SRC
***** Dependent matching

*** Definitions
**** Let
**** Modules
**** Signatures
**** Types
*** String Literals
*** Tuples
*** Lists
List literals are started by the open bracket character (=[=). Within,
elements are separated by commas (=,=) before ending with a closing
bracket (=]=)

#+BEGIN_SRC haskell
  -- this is a valid list
  [1]

  -- another valid list
  [1,2,3]
#+END_SRC
*** Do Notation
*** Constants
*** Local opens
