* Syntax Guide
This document is heavily inspired by the [[http://docs.idris-lang.org/en/latest/reference/syntax-guide.html][Idris syntax guide]].
** File Organization
A file contains zero or more [[Top Level Declarations]]

For example
#+BEGIN_SRC ocaml
  -- this is a function with a signature!
  sig foo : Natural
  let foo = 3

  -- this is a data type declaration
  type list a = Cons a (List a)
              | Nil

  -- this is a module declaration!
  mod Boo =
    let fi = 10
  end
#+END_SRC
** Comments
Comments are denoted by two dashes, =--=, and it and all characters up
until the end of the line are discarded

Example:
#+BEGIN_SRC ocaml
  -- This is a comment!
#+END_SRC
** Symbols
Symbols are used for any name declared in the Juvix programming
language. Symbols are broken into two categories, infix and prefix

Prefix symbols start with either an alpha character or an underscore,
which can be followed up by any alphanumeric character, underscores,
punctuation(?, !), or dashes.

#+BEGIN_SRC haskell

  -- a valid symbol
  hello-there

  -- another valid symbol
  _unused-symbol

  -- a valid predicate
  even?

  -- An important action
  foo!

  -- not a valid prefix symbol
  -foo
#+END_SRC

An infix symbol starts with all other symbols including punctuation
and dashes

#+BEGIN_SRC haskell
  -- This is a valid infix symbol

  !!

  -- this is also another valid infix symbol

  -<++

  -- this is not a valid infix symbol, but instead a comment of a -

  ---

  -- here is an arrow infix symbol

  ->
#+END_SRC

** Top Level Declarations
*** Functions

Functions are started by writing =let= which is followed by any valid
prefix symbol or an infix symbol surrounded by parenthesis which shall
be refereed to as the function name. Then, there are zero or more
arguments, implicit arguments are surrounded in curly braces
(={}=). The arguments are ended when an equal sign (===) is placed,
which denotes the start of the body.

Example:
#+BEGIN_SRC ocaml
  -- this is a valid function

  let f x = x + 3

  -- this is another valid variable/function

  let y = 5

  -- this is a valid infix symbol

  let (+) = plus


  -- a function with an implicit argument
  let foo {prf} x = x
#+END_SRC

Another important part of a function is the signature.

A signature is denoted first by sig, then the function name. From here
colon (=:=) denotes the start of the type of the function name. From
here any valid type can be written.

Example:
#+BEGIN_SRC ocaml
  -- a valid signature and function
  sig foo : int -> int
  let foo x = x + 3


  -- an example of a dependent signature
  sig add
      :  x : nat
      -> y : int
      -> if | x > y -> nat
            | else  -> int
  let add = (+)
#+END_SRC
*** Types
*** Modules
modules are denoted similarly to modules except that instead of using
=let=, =mod= is used instead.

And instead of the body being an expression, the body is zero or more
top level declarations before =end= is found

#+BEGIN_SRC haskell

  -- example defining a module

  mod Foo =
    sig bar : nat
    let bar = 3

    let baz = 5

  -- end ends the module definition
  end

  -- example using a module
  let test = Foo.bar + Foo.baz
#+END_SRC
*** Imports
one can import a module in two ways.

Either by opening them

Example:
#+BEGIN_SRC ocaml
  -- A valid open
  open Foo

  open Foo.Bar.Baz
#+END_SRC

or aliasing them with a let

Example:
#+BEGIN_SRC ocaml
  -- a valid module alias
  let F = Foo
#+END_SRC

** Expressions
*** Conditionals
**** If
If expressions have a non zero number of clauses. Each clause consists
of a boolean test, followed by a consequence.

Example:
#+BEGIN_SRC haskell
  -- this is a valid if expression!
  if | x == 3 -> 5
     | else   -> 6
  -- ^ test      ^ consequence

  -- this is also a valid a valid if expression
  if | x == 10     -> 25
     | positive? x -> x
     | negative? x -> abs x
     | else        -> 0
#+END_SRC

The =else= name is just an alias for =False=.
**** Case
Case expressions have a non zero number of clauses. Each clause
consists of a pattern, followed by a consequence.

A pattern works much like Haskell or Idris, in that one can
deconstruct on a record or a constructor. We also allow record punning
on matches.

Example:
#+BEGIN_SRC ocaml
  type tree a = Branch (tree a) a (tree a)
              | Leaf a
              | Empty


  -- an example with match!
  let func foo =
    case foo of
    | Branch left ele right ->
      func left + ele + func right
    | Leaf ele ->
      ele
    | Empty ->
      0


  -- This is the same function!
  let func (Branch left ele right) =
    func left + ele + func right
  let func (Leaf ele) =
    ele
  let func Empty =
    0


  type cords = {
    x : int,
    y : int
  }

  -- match on record

  sig origin? : cords -> boolean
  let origin? {x, y}
    | x == y && x == 0 = True
    | else             = False

  -- same function as origin
  sig origin2? : cords -> boolean
  let origin2? {x = origX, y = origY}
    | origX == origY && origX == 0 =
      True
    | else = False
#+END_SRC
***** Dependent matching

*** Definitions
All definitions are like their top level counter part, except that =in=
followed by an expression is written afterwords
**** Let
# Add and example of and once and is in

#+BEGIN_SRC ocaml
  let foo =
    let bar = 3 in
    bar + 10
#+END_SRC
**** Modules
#+BEGIN_SRC ocaml
  let foo =
    mod Bar =
      let foo = 3
      let bat = 10
    end in
    Bar.foo + Bar.bat
#+END_SRC
**** Signatures
**** Types
#+BEGIN_SRC ocaml
  let foo =
    type bar = Foo int
             | Bar nat
    in [Foo 3, Bar 10]
#+END_SRC
*** String Literals
Strings are enclosed by double quotes (="=)
# add escape characters once they are in

*** Lists
List literals are started by the open bracket character (=[=). Within,
elements are separated by commas (=,=) before ending with a closing
bracket (=]=)

Example:?
#+BEGIN_SRC haskell
  -- this is a valid list
  [1]

  -- another valid list
  [1,2,3]
#+END_SRC
*** Tuples
Tuples are formatted like lists, however instead of using brackets,
parenthesis are used instead ( =(= =)= ).

Example:
#+BEGIN_SRC haskell
  -- this is a tuple
  (1, 2)

  -- this is not a tuple
  (1)

  -- this is a 5 tuple!
  (1,2,3,4,5)
#+END_SRC
*** Do Notation
*** Constants
*** Local opens

Local opens work just like global open, however one has to write =in=
then a body like other defining expressions.

Example:
#+BEGIN_SRC ocaml
  let foo xs ys zs =
    open List in
    append xs (append ys zs)
#+END_SRC

There is also a more brief syntax where the module is then following
by =.( ... code here ... )=

Example:
#+BEGIN_SRC ocaml
  let foo xs ys zs =
    List.(append xs (append ys zs))
#+END_SRC
