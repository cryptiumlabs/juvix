---
title: Juvix — Language Reference
mainfont: DejaVuSerifCondensed
fontsize: 7pt
author: Christopher Goes
date: \textit{Prerelease}
urlcolor: cyan
abstract: Juvix encapsulates a high-level frontend syntax, dependent-linearly-typed core language, and parallelizable
          low-level execution model into a single unified stack for writing formally verifiable, efficient smart contracts which can be
          deployed to a variety of distributed ledgers. Juvix's compiler architecture has been purpose-built from the
          ground up for the particular requirements and economic tradeoffs of the smart contract use case — it prioritizes
          verifiability, precision, and output code efficiency over compilation speed, syntax familiarity, and compatibility with existing
          virtual machines.
          Machine-assisted proof search, streamlined tooling, and alternative spatiotemporal dataflow representations faciliate
          integration of low-developer-overhead property verification into the development process.
          An interchain abstraction layer representing ledgers as first-class objects facilitates stateful
          contract deployment, seamless cross-chain programming, and typesafe runtime reconfiguration.
header-includes:
    - \usepackage{fancyhdr}
    - \usepackage{graphicx}
    - \usepackage{hyperref}
    - \usepackage{bussproofs}
    - \usepackage{amsmath}
    - \usepackage{spaghettinet}
    - \usepackage{cmll}
    - \pagestyle{fancy}
    - \fancyhead[RE,LO]{Juvix — Language Reference}
    - \fancyhead[LE,RO]{}
    - \fancyhead[CO,CE]{}
    - \fancyfoot[CO,CE]{}
    - \fancyfoot[LE,RO]{\thepage}
---

\pagebreak

# Motivation

# Prior Work

## Dependently-typed languages

Why have dependently-typed languages not yet succeeded?

1. Inefficient compilation
1. Too hard / too much effort to write proofs
1. Economics didn't favor safety (compile time, speed of development matters more)
1. Not enough engineering effort dedicated

## Dependently-typed smart contracts

One prior work [@safer-smart-contracts-through-type-driven-development] wrote an Idris [@idris-systems-programming-meets-full-dependent-types] backend targeting Ethereum's LLL language [@lisp-like-language]. Juvix shares many of the goals outlined in that paper, but the approach described failed to take advantage of well-known optimizations such as tail-call optimization and handicapped itself by compiling to LLL instead of directly to EVM opcodes. The effects system described therein may be a sensible model for smart contract programs written in Juvix but is out of scope of this paper.

Formality [@formality] was a substantial inspiration for this work, particularly the low-level interaction net execution model. Juvix differs in its willingness to implement a larger core language and low-level execution model and trade some simplicity for performance where the performance gains are substantial.

# Reasoning

Why will Juvix fix these problems?

## Efficient compilation

### Compiler-level optimizations

1. Efficient TCO
1. More efficient datatype representation (Cedille?)
1. Large reductions (Cedille?)
1. Closures, investigate
1. Linear types
1. Supercompilation

### Developer-level optimizations
        
1. Expose underlying VM primitives, expose interpreter
1. Allow safe rewrites to more efficient implementations

### Execution model

1. Interaction nets, custom rewrite rules, optimal lambda reduction

## Time-efficient formal proof constructions

1. Assistance for proof generation, ecosystem for composable proofs
    1. Libraries of proofs for common functionality
    1. Graph search for asserted properties
    1. "Prototype first, proofs later"

## Not just safe - possible

1. Make safety cheaper, smart contracts need it, enable more complex systems
    1. Correctness necessary
    1. Compile time doesn't matter, small programs, can supercompile/search
    1. Code reuse (even on-chain)
1. Leverage power of dependent types for safe, complex interchain logic
    1. "Abstraction limits" hit by interacting Ethereum contracts
        1. Typecheck across contracts
        1. Contracts require types of callers / callees
    1. Safe cross-contract optimization using known types
    1. Safe upgrades (prove semantical equivalence, anyone can upgrade contract)

# Components

# Frontend language

High-level dependently-typed language.

## Syntax

Syntax options:

1. Idris [@idris-systems-programming-meets-full-dependent-types] / Haskell [@haskell] favored
1. Lisp-like [@common-lisp]

## Semantics

# Core language

## Type theory

Combines linear & dependent types.

Key problem: linear function splits up resources for production of argument & function. What if function type depends on argument? Doesn't make sense.

Assigning evaluative costs, dealing with if-conditionals, etc.

### Basics

Inspired by Cedille [@the-calculus-of-dependent-lambda-eliminations], Quantitative Type Theory [@quantitative-type-theory], and Formality [@formality].

A *semiring* $R$ is a set $R$ with binary operations $+$ (addition) and $⋅$ (multiplication), such that $(R, +)$ is a commutative monoid with identity $0$,
$(R, ⋅)$ is a monoid with identity $1$, multiplication left and right distributed over addition, and multiplication by $0$ annihilates $R$.

The type theory of Juvix Core must be instantiated over a particular semiring. Choices include the boolean semiring $(0, 1)$, the zero-one-many semiring $(0, 1, ω)$, and the natural numbers with addition and multiplication. In practice Juvix is instantiated over the semiring of natural numbers, which is the most expressive option.

Typing judgements in Juvix Type Theory (JTT) have the following form:

$$ x_1 \overset{ρ_1}{:} S_1, ..., x_n \overset{ρ_n}{:} S_n \vdash\ M \overset{σ}{:} T $$

where $ρ_1 ... ρ_n$ are elements of the semiring and $σ$ is either the $0$ or $1$ of the semiring.

JTT is defined over the syntactic categories of usages $ρ, π$, precontexts $Γ$, pretypes $S,T,R$, and preterms $M,N,O$:

\begin{align*}
ρ,π ∈ R (1) \\
\\
Γ := ⋄\ |\ Γ,x \overset{ρ}{:} S \\
\\
S, T, U := (x \overset{π}{:} S) → T\ |\ (x \overset{π}{:} S) ⊗ T\ |\ I\ |\ Set \\
\\
M, N, O := x\ |\ λx \overset{π}{:} S.M^T\ |\ App_{(x \overset{π}{:} S)T} (M,N) \\
            \ |\ (M,N)_{x \overset{π}{:} S . T}\ |\ ∗\ |\ let_I ∗ = M\ in\ N\ |\ (x \overset{π}{:} M) → N
\end{align*}

The symbol ⋄ denotes the empty precontext.

Precontexts contain usage annotations $ρ$ on constituent variables. Scaling a context, $πΓ$, is defined as follows:

\begin{align}
π(⋄)=⋄ \\
π(Γ,x \overset{ρ}{:} S) = πΓ,x \overset{πρ}{:} S
\end{align}

Usage annotations in pretypes are not affected.

$0Γ$ sets all annotations to $0$.

Addition of two precontexts $Γ_1+Γ_2$ is defined when $0Γ_1=0Γ_2$:

\begin{align}
⋄+⋄=⋄\\
(Γ_1,x \overset{ρ_1}{:} S) + (Γ_2,x \overset{ρ_2}{:} S) = (Γ_1+Γ_2), x \overset{p_1 + p_2}{:} S
\end{align}

Contexts are identified by the judgement $Γ\vdash$, defined by the following rules:

\begin{prooftree}
\AxiomC{}
\RightLabel{Emp}
\UnaryInfC{⋄\vdash}
\end{prooftree}

\begin{prooftree}
\AxiomC{$Γ \vdash$}
\AxiomC{$0Γ⊢S$}
\RightLabel{Ext}
\BinaryInfC{$Γ,x \overset{ρ}{:} S \vdash$}
\end{prooftree}

$0Γ⊢S$ indicates that $S$ is well-formed as a type in the context of $0Γ$.
$Emp$, for "empty", builds the empty context, and $Ext$, for "extend", extends a context $Γ$ with a new variable $x$ of type $S$ and usage annotation $ρ$.
All type formation rules yield judgements where all usage annotations in $Γ$ are $0$ (type formation requires no computational resources).

Term judgements have the form:

\begin{align}
Γ ⊢ M \overset{σ}{:} S
\end{align}

### Variable & conversion rules

where $σ ∈ {0,1}$. A judgement with $σ = 0$ constructs a term with no computational content, while a judgement with $σ = 1$ constructs a term which will be computed.

The variable rule selects an individual variable, type, and usage annotation from the context:

\begin{prooftree}
\AxiomC{$⊢ 0Γ,x \overset{σ}{:} S, 0Γ′$}
\RightLabel{Var}
\UnaryInfC{$0Γ,x \overset{σ}{:} S, 0Γ′ ⊢ x \overset{σ}{:} S$}
\end{prooftree}

The conversion rule:

\begin{prooftree}
\AxiomC{$Γ ⊢ M \overset{σ}{:} S$}
\AxiomC{$0Γ ⊢ S≡T$}
\RightLabel{Conv}
\BinaryInfC{$Γ ⊢ M \overset{σ}{:} T$}
\end{prooftree}

Note that type equality is judged in a context with no resources.

### Dependent function types

Function types $(x \overset{π}{:} S) → T$ record usage of the argument. The formation rule is:

\begin{prooftree}
\AxiomC{$0Γ ⊢ S$}
\AxiomC{$0Γ,x \overset{0}{:} S ⊢ T$}
\RightLabel{Pi}
\BinaryInfC{$0Γ ⊢ (x \overset{π}{:} S) → T$}
\end{prooftree}

The usage annotation $π$ is not used in judgement of whether $T$ is a well-formed type. It is used
in the introduction and elimination rules to track how $x$ is used, and how to multiply the resources
required for the argument, respectively:

\begin{prooftree}
\AxiomC{$Γ,x \overset{σπ}{:} S ⊢ M \overset{σ}{:} T$}
\RightLabel{Lam}
\UnaryInfC{$Γ ⊢ λx \overset{π}{:} S.M^T \overset{σ}{:} (x \overset{π}{:} S) → T$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$Γ_1 ⊢ M \overset{σ}{:} (x \overset{π}{:} S) → T$}
\AxiomC{$Γ_2 ⊢ N \overset{σ′}{:} S$}
\AxiomC{$0Γ_1 = 0Γ_2$}
\AxiomC{$σ′=0 ⇔ (π=0 ∨ σ=0)$}
\RightLabel{App}
\QuaternaryInfC{$Γ_1 + πΓ_2 ⊢ App_{(x \overset{π}{:} S) T}(M,N) \overset{σ}{:} T[N/x]$}
\end{prooftree}

- $0Γ_1 = 0Γ_2$ means that $Γ_1$ and $Γ_2$ have the same variables with the same types
- In the introduction rule, the abstracted variable $x$ has usage $σπ$ so that non-computational production requires no computational input
- In the elimination rule, the resources required by the function and its argument, scaled to the amount required by the function, are summed
- The function argument $N$ may be judged in the 0-use fragment of the system if and only if we are already in the 0-use fragment ($σ=0$) or the function will not use the argument ($π=0$).

### Dependent multiplicative conjunction (tensor product)

Dependent tensor production formation rule:

\begin{prooftree}
\AxiomC{$0Γ ⊢ A$}
\AxiomC{$0Γ,x \overset{0}{:} S ⊢ T$}
\RightLabel{⊗}
\BinaryInfC{$0Γ ⊢ (x \overset{π}{:} S) ⊗ T$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$0Γ ⊢$}
\RightLabel{I}
\UnaryInfC{$0Γ ⊢ I$}
\end{prooftree}

Type formation does not require any resources.

Introduction rule:

\begin{prooftree}
\AxiomC{$Γ_1 ⊢ M \overset{σ′}{:} S$}
\AxiomC{$0Γ_1 = 0Γ_2$}
\AxiomC{$Γ_2 ⊢ N \overset{σ}{:} T[M/x]$}
\AxiomC{$σ′=0 ⇔ (π=0 ∨ σ=0)$}
\QuaternaryInfC{$πΓ_1 + Γ_2 ⊢ (M,N)_{x \overset{π}{:} S.T} \overset{σ}{:} (x \overset{π}{:} S) ⊗ T$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$0Γ ⊢$}
\UnaryInfC{$0Γ ⊢ ∗ \overset{σ}{:} I$}
\end{prooftree}

This is similar to the introduction rule for dependent function types above.

Elimination rule:

Under the erased ($σ=0$) part of the theory, projection operators can be used as normal:

\begin{prooftree}
\AxiomC{$Γ ⊢ M \overset{0}{:} (x \overset{π}{:} S) ⊗ T$}
\UnaryInfC{$Γ ⊢ fst_{x \overset{π}{:} S.T} (M) \overset{0}{:} A$}
\end{prooftree}

(should the last be $S$ ?)

\begin{prooftree}
\AxiomC{$Γ ⊢ M \overset{0}{:} (x \overset{π}{:} S) ⊗ T$}
\UnaryInfC{$Γ ⊢ snd_{x \overset{π}{:} S.T} (M) \overset{0}{:} T[fst(M)/x]$}
\end{prooftree}

Under the resourceful part:

\begin{prooftree}
\AxiomC{$0Γ_1, z \overset{0}{:} (x \overset{π}{:} S) ⊗ T ⊢ U$}
\AxiomC{$Γ_1 ⊢ M \overset{σ}{:} (x \overset{π}{:} S) ⊗ T$}
\AxiomC{$Γ_2, x \overset{σπ}{:} S, y \overset{σ}{:} T ⊢ N \overset{σ}{:} U[(x,y)/z]$}
\AxiomC{$0Γ_1 = 0Γ_2$}
\RightLabel{$⊗$ Elim}
\QuaternaryInfC{$Γ_1+Γ_2 ⊢ let_{x \overset{π}{:} S.T} (x,y) = M\ in\ N \overset{σ}{:} U[M/z]$}
\end{prooftree}

- Must pattern match out to ensure both parts of the product are used.

\begin{prooftree}
\AxiomC{$0Γ_1, x \overset{0}{:} I ⊢ U$}
\AxiomC{$Γ_1 ⊢ M \overset{σ}{:} I$}
\AxiomC{$Γ_2 ⊢ N \overset{σ}{:} U[∗/x]$}
\AxiomC{$0Γ_1 = 0Γ_2$}
\RightLabel{$⊗$ Elim I}
\QuaternaryInfC{$Γ_1 + Γ_2 ⊢ let_I ∗ = M\ in\ N \overset{σ}{:} U[M/x]$}
\end{prooftree}

- Must explicitly eliminate elements of the unit type in the resourceful fragment.
- Simplifies to fst, snd in $σ=0$ fragment (should we combine the rules?)

### Multiplicative disjunction

"Both separately in parallel"

Cannot be dependent?

Introduction rule:

\begin{prooftree}
\AxiomC{$Γ ⊢ (A \overset{σ}{:} S), (B \overset{σ'}{:} S')$}
\RightLabel{$\parr$}
\UnaryInfC{$Γ ⊢ (A \overset{σ}{:} S) \parr (B \overset{σ'}{:} S')$}
\end{prooftree}

is this right?

### Additive conjunction

"Choose either"

Can be dependent

Introduction rule:

\begin{prooftree}
\AxiomC{$Γ ⊢ A \overset{σ}{∶} S$}
\AxiomC{$Γ ⊢ B \overset{σ}{:} S$}
\RightLabel{$\&$}
\BinaryInfC{$Γ ⊢ (A \overset{σ}{∶} S) \& (B \overset{σ}{:} S)$}
\end{prooftree}

Can we have $σ$ and $σ'$?

### Additive disjunction

"Might be either"

Cannot be dependent?

Introduction rules:

\begin{prooftree}
\AxiomC{$Γ ⊢ A \overset{σ}{∶} S$}
\RightLabel{$⊕_L$}
\UnaryInfC{$Γ ⊢ (A \overset{σ}{∶} S) ⊕ (B \overset{σ'}{:} S)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$Γ ⊢ B \overset{σ}{∶} S$}
\RightLabel{$⊕_R$}
\UnaryInfC{$Γ ⊢ (A \overset{σ'}{∶} S) ⊕ (B \overset{σ}{:} S)$}
\end{prooftree}

### Universe (set type)

Formation rule:

\begin{prooftree}
\AxiomC{$0Γ ⊢$}
\RightLabel{Set}
\UnaryInfC{$0Γ ⊢ Set$}
\end{prooftree}

Introduction rule ($σ = 0$ fragment only):

\begin{prooftree}
\AxiomC{$0Γ ⊢ M \overset{0}{:} Set$}
\AxiomC{$0Γ, x \overset{0}{:} El(M) ⊢ N \overset{0}{:} Set$}
\RightLabel{Set-Pi}
\BinaryInfC{$Γ ⊢ (x \overset{π}{:} M) → N \overset{0}{:} Set$}
\end{prooftree}

Elimination rule:

\begin{prooftree}
\AxiomC{$0Γ ⊢ M \overset{0}{:} Set$}
\RightLabel{Set-El}
\UnaryInfC{$0Γ ⊢ El(M)$}
\end{prooftree}

can we encode everything we want in lambda calculus in this type system?

subusaging? seems cool

more things

- figure out what R-linear combinatory algebras are
- figure out how best to add primitive types
- figure out how this translates into an implementation, see McBride's paper
- ensure we can derive induction, see Cedille

## Syntax

## Semantics

# Low-level execution model

## Optimal reduction

See Optimal Lambda Calculus Reduction [@an-algorithm-for-optimal-lambda-calculus-reduction]

## Interaction nets

Interaction nets as target computational model.
Interaction net interpreters / compilers in Michelson, EVM, WASM.

## Core language encoding

Compared with previous interaction net interpreters for the lambda calculus utilizing a static set
of node types and fixed rewrite rules, Juvix adds an additional degree of freedom:
the node types and rewrite rules of the interaction system can be generated at compile time and even
dynamically altered at runtime according to usage patterns and desired time-space complexity tradeoffs.

\begin{tikzpicture}
\inetbigcell[angle=130]{a}{$\lambda$}[5]
\inetbigcell[angle=130, right=100pt]{b}{$@$}[5]

\inwire{a/1}{}
\inwire{a/4}{}
\inwire{b/1}{}
\inwire{b/4}{}

\cutWire{a.out}{b.out}{}{}
\end{tikzpicture}

How to encode other linear logic types?

## Optimization

### Spacial memory contiguity

Ensure correspondence between graphical locality and spacial locality in memory.

### Speculative execution

- "Strict" optimal reduction strategies
- Evaluate based on predicting future input (feasible?)

# Extensions

## Platform targets

In each case, two options: interaction net interpreter & direct compilation.

### WASM

### Michelson

### EVM

# Future Directions

## Zero-knowledge execution compression

1. Run interaction nets in ZK

## State machine integration

1. Defined equalence semantics but implementation can change later
1. Contracts themselves can call the compiler (needs more R&D)
1. Bounties for proofs, sub-contract-upgrades, etc.

## Interchain abstraction

1. Can run cross-chain over IBC
1. Targets multiple backends (Ethereum, Tezos, Cosmos) initially
1. Avoid lock-in, separate choice of application and choice of consensus

## Visual representation

1. Inspiration: Luna [@luna-lang]

# Appendices

## Examples

# References
