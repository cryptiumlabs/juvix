## Syntax

Define:

1. Formulae $A,B ::=\ α\ |\ A ⊸ B\ |\ !A\ |\ ∀α.A$.
1. Pseudoterms $t,u ::= x\ |\ λx.t\ |\ (t)u\ |\ !t\ |\ \bar{!}t$.
1. Restricted pseudoterms
    1. $a ::= x\ |\ λx.t\ |\ (t)t$
    1. $t ::= !^m a$ where
        1. $m \in \mathbb{Z}$
        1. $!^ma =\ !...!\ (m\ times)\ a\ if m ≥ 0$
        1. $!^ma = \bar{!}...\bar{!}\ (m\ times)\ a\ if\ m < 0$

## Typing rules

\begin{figure}[h]
\caption{Typing rules for EAL}

\begin{prooftree}
\AxiomC{}
\RightLabel{var}
\UnaryInfC{$x:A ⊢ x:A$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$Γ ⊢ t:B$}
\RightLabel{weak}
\UnaryInfC{$Γ, x:A ⊢ t:B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$Γ_1 ⊢ t_1:A ⊸ B$}
\AxiomC{$Γ_2 ⊢ t_2:A$}
\RightLabel{app}
\BinaryInfC{$Γ_1,Γ_2 ⊢ (t_1 t_2):B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$Γ,x:A ⊢ t:B$}
\RightLabel{abst}
\UnaryInfC{$Γ ⊢ λx.t:A ⊸ B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$Γ_1 ⊢ t_1:\ !A_1, ..., Γ_n ⊢ t_n:\ !A_n$}
\AxiomC{$x_1:A_1, ..., x_n:A_n ⊢ t:B$}
\RightLabel{prom}
\BinaryInfC{$Γ_1, ..., Γ_n ⊢ !t[\bar{!}t_i/x_i]:\ !B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$x_1:\ !A, ..., x_n:\ !A, ∆ ⊢ t:B$}
\RightLabel{contr}
\UnaryInfC{$x:\ !A, ∆ ⊢ t[x/x_1,...,x_n]:B$}
\end{prooftree}

\end{figure}

## Erasure to untyped lambda calculus

## Type inference

### Box paths

### Parameterization

### Constraint generation

### Constraint solution

\begin{figure}[h]
\caption{Typing rules for DTEAL (TODO)}

\begin{prooftree}
\AxiomC{$Γ,x:A ⊢ t:B$}
\RightLabel{abst}
\UnaryInfC{$Γ ⊢ λx.t: \prod A. B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$Γ,x:A ⊢ B: *$}
\RightLabel{pi}
\UnaryInfC{$Γ ⊢ \prod x: A. B : *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$Γ_1 ⊢ t_1:\prod A. B$}
\AxiomC{$Γ_2 ⊢ t_2:A$}
\RightLabel{app}
\BinaryInfC{$Γ_1,Γ_2 ⊢ (t_1 t_2):B[t_2/A]$}
\end{prooftree}

\end{figure}

Q: Can we just split up the context in the (app) rule without problems? Equivalent to zero-usage in QTT?

think about how to correctly translate r = lam-case 1 -> 2Y; 2 -> 3Z, h = (r & x) -> a, constraints should reflect dependently-typed usage calculations (though maybe we don't care for >= 2 usages).


