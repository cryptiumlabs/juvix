## Syntax

Define:

## Semantics

- Define evaluation semantics, undefined behaviour.

## Typing rules

\begin{figure}[h]
\caption{Typing rules for EAL}

\begin{prooftree}
\AxiomC{}
\RightLabel{var}
\UnaryInfC{$x:A ⊢ x:A$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$Γ ⊢ t:B$}
\RightLabel{weak}
\UnaryInfC{$Γ, x:A ⊢ t:B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$Γ_1 ⊢ t_1:A ⊸ B$}
\AxiomC{$Γ_2 ⊢ t_2:A$}
\RightLabel{app}
\BinaryInfC{$Γ_1,Γ_2 ⊢ (t_1 t_2):B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$Γ,x:A ⊢ t:B$}
\RightLabel{abst}
\UnaryInfC{$Γ ⊢ λx.t:A ⊸ B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$Γ_1 ⊢ t_1:\ !A_1, ..., Γ_n ⊢ t_n:\ !A_n$}
\AxiomC{$x_1:A_1, ..., x_n:A_n ⊢ t:B$}
\RightLabel{prom}
\BinaryInfC{$Γ_1, ..., Γ_n ⊢ !t[\bar{!}t_i/x_i]:\ !B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$x_1:\ !A, ..., x_n:\ !A, ∆ ⊢ t:B$}
\RightLabel{contr}
\UnaryInfC{$x:\ !A, ∆ ⊢ t[x/x_1,...,x_n]:B$}
\end{prooftree}

\end{figure}

## Erasure to untyped lambda calculus

## Type inference

Adapted from previous work [@feasible-algorithm-typing-eal].

Why / notes

- Boxes are unintuitive to write, add syntactic bureacracy
- Inference will sometimes fail. In this case, programmer can be informed and suggested how else to write their function, or alternatively the bespoke encoding route can be taken.
- Most terms one would want to compute (especially in smart contracts) are in the elementary complexity class
- Allows better box placement than programmer might choose, compiler can pick from set of typeable EAL terms & instantiate with fewest number / optimally positioned boxes

Define:

1. Formulae $A,B ::=\ α\ |\ A ⊸ B\ |\ !A\ |\ ∀α.A$.
1. Pseudoterms $t,u ::= x\ |\ λx.t\ |\ (t)u\ |\ !t\ |\ \bar{!}t$.
1. Restricted pseudoterms
    1. $a ::= x\ |\ λx.t\ |\ (t)t$
    1. $t ::= !^m a$ where
        1. $m \in \mathbb{Z}$
        1. $!^ma =\ !...!\ (m\ times)\ a\ if m ≥ 0$
        1. $!^ma = \bar{!}...\bar{!}\ (m\ times)\ a\ if\ m < 0$

All typable terms can be converted into restricted pseudo-terms (for proof see the paper).

### Box paths

Where $t$ is a pseudo-term and $x$ is an occurrence of a free or bound variable in $t$, define the **path** as an ordered list of the occurrences of $!$ and $\bar{!}$ enclosing $x$, more formally:

\begin{align}
path(x, x)        = nil
path(t_1 t_2, x)  = path(t_i, x) where t_i contains x
path(λy.t, x)     = path(t, x)
path(!t, x)       = ! :: path(t, x)
path(\bar{!}t, x) = \bar{!}t :: path(t, x)
\end{align}

### Parameterization

### Constraint generation

### Constraint solution

\begin{figure}[h]
\caption{Typing rules for DTEAL (TODO)}

\begin{prooftree}
\AxiomC{$Γ,x:A ⊢ t:B$}
\RightLabel{abst}
\UnaryInfC{$Γ ⊢ λx.t: \prod A. B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$Γ,x:A ⊢ B: *$}
\RightLabel{pi}
\UnaryInfC{$Γ ⊢ \prod x: A. B : *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$Γ_1 ⊢ t_1:\prod A. B$}
\AxiomC{$Γ_2 ⊢ t_2:A$}
\RightLabel{app}
\BinaryInfC{$Γ_1,Γ_2 ⊢ (t_1 t_2):B[t_2/A]$}
\end{prooftree}

\end{figure}

Q: Can we just split up the context in the (app) rule without problems? Equivalent to zero-usage in QTT?

think about how to correctly translate r = lam-case 1 -> 2Y; 2 -> 3Z, h = (r & x) -> a, constraints should reflect dependently-typed usage calculations (though maybe we don't care for >= 2 usages).
