This chapter defines the high-level dependently-typed frontend syntax in which developers are expected to write, referred to as the "Juvix frontend language" or merely "Juvix" where unambiguous. 

> Note that the frontend language is one of the less theoretically risky parts of the compiler design and thus is omitted in the initial release, except for algebraic datatypes. At present developers code directly in Juvix Core (which will always be possible).

## Syntax

Syntax options:

1. Idris [@idris-systems-programming-meets-full-dependent-types] / Haskell [@haskell] favored
1. Lisp-like [@common-lisp]

## Features

- Nested, dependent pattern matching
- Typeclasses a la Idris
- Implicit arguments a la Idris (mostly)
- Linear variable usage annotations over the integer semiring, syntax a bit like [Granule](https://granule-project.github.io/granule.html) perhaps
- Case expressions
- Algebraic datatypes
- Elaboration, tactics a la Idris
- Holes
- Type inference (when possible)

Most features simply desugar to Core.

## Lambda-encoding of algebraic datatypes

### Mendler

Mendler style F-agebras have the unqiue advantage of being strongly normalizing for positive and negative inductive datatypes while not sacrificng constant time destructors or a linear representation. This is achieved through the Mendler representation of the algebraic datatype being a catamorphism with an explicit recrusive deconstructor. The strongly normalizing property of the Mendler style algebra is only achieved in the abscense of external deconstructors (todo :: find source)

Let us first explore the core of the encoding by first assuming we have access to a non inductive algebraic data type, then strip these assumptions until just base lambda calculus is left.

The first example we will explore is the natural numbers. Recall that the natural numbers can be defined as such

```
-- Normal Haskell way of defining Nat
data Nat = Z
         | S Nat

```

Now, let us strip the recursive nature of this data type using pusdo haskell syntax
```
data N r = Z
         | S r

let in = \r. \f. f (\d. d f) r

type AlgebraM (f :: * → *) (x :: *) = forall (r :: *). (r → x) → (f r) → x

type FixM f = forall x. AlgebraM f x → x

type Nat = FixM N

let zero = in Z : Nat
let succ = \n. in (S n) : Nat → Nat
```

The interesting definitions above to pay attention to are `AlgebraM` and `in`.


(todo: list asymptotic complexities, concrete complexities, encoding algorithm)

### Scott

(todo: list asymptotic complexities, concrete complexities, encoding algorithm)

## Desugaring

(todo)
