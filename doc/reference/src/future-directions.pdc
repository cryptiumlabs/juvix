## Zero-knowledge execution compression

1. Run interaction nets in ZK
1. Might benefit from the parallelism

## Zero-knowledge typing

1. Earlier than execution compression.
1. Inline ZK verifiers + proofs as custom node types.
1. Type data as "private" or "public" at the monadic level, compiler-enforced.

## Deployment tooling layer

1. Ledgers as first-class objects in declarative deployment scripts.
1. Declarative-stateful deployment system Terraform-style.
1. Blockchains accessible in REPL.

## Persistent interaction system state

1. Defined equivalence semantics but implementation can change later
1. Contracts themselves can call the compiler (needs more R&D)
1. Bounties for proofs, sub-contract-upgrades, etc.
1. More efficient than read-back after execution, just persist the graph of the state machine, many more optimisations automatically happen.
1. Will be helpful for Juvix to be self-hosting or packaged as a runtime which can typecheck untrusted input.

## Interchain abstraction

1. Can run cross-chain over IBC
1. Targets multiple backends (Ethereum, Tezos, Cosmos) initially
1. Avoid lock-in, separate choice of application and choice of consensus

## Visual spatiotemporal dataflow representation

1. Some (closest?) inspiration: Luna [@luna-lang]
1. Could map depths of elementary linear logic terms to spacial depth in an execution visualisation
1. Goal: isomorphism between textual (AST) and graphical (dataflow graph) representations. Getting the isomorphism right so that they can be switched between for real projects seems like the hard part.
