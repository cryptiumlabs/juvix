---
title: Juvix — Language Reference
lang: en-GB
titlepage: true
titlepage-color: "06386e"
titlepage-text-color: "FFFFFF"
titlepage-rule-color: "FFFFFF"
titlepage-rule-height: 1
toc-own-page: true
mainfont: DejaVuSerifCondensed
fontsize: 7pt
author: Christopher Goes, Marty Stumpf, Jeremy Ornelas
date: \today \ - \textit{Prerelease}
urlcolor: cyan
abstract: Juvix synthesizes a high-level frontend syntax, dependent-linearly-typed core language, and low-level parallelizable
          optimally-reducing execution model into a single unified stack for writing formally verifiable, efficiently executable smart contracts which can be
          deployed to a variety of distributed ledgers.
          \par
          Juvix's compiler architecture has been purpose-built from the ground up for the particular requirements and economic tradeoffs
          of the smart contract use case — it prioritizes verifiability, precision, and output code efficiency over compilation speed,
          syntactical & semantic familiarity, and compatibility with existing blockchain virtual machines.
          Machine-assisted proof search, declarative deployment tooling, cogent type inference, and alternative spatiotemporal dataflow representations faciliate
          integration of low-developer-overhead property verification into the development process.
          An interchain abstraction layer representing ledgers as first-class objects enables seamless cross-chain programming and typesafe runtime reconfiguration.
          \par
          This document is designed to be a first-principles explanation of Juvix. No familiarity with the theoretical background is assumed.
          Readers previously acquainted with the lambda calculus, sequent calculus, simply-typed lambda calculus, the calculus of constructions,
          linear logic, interaction nets, elementary affine logic, and Lamping's optimal reduction algorithm may skip the associated subsections in chapter five.
header-includes:
    - \usepackage{graphicx}
    - \usepackage{hyperref}
    - \usepackage{bussproofs}
    - \usepackage{amsmath}
    - \usepackage{spaghettinet}
    - \usepackage{cmll}
    - \usepackage{microtype}
    - \usepackage{float}
    - \floatstyle{boxed}
    - \restylefloat{figure}
    - \usepackage{tikz}
    - \usetikzlibrary{arrows,automata}
    - \newtheorem{theorem}{Theorem}
---

\pagebreak

# Motivation

!include src/motivation.pdc

# Typographical conventions

!include src/typographical-conventions.pdc

# Prior work

!include src/prior-work.pdc

# Reasoning

!include src/reasoning.pdc

# Theoretical background

!include src/theoretical-background.pdc

## Lambda calculus

!include src/background/lambda-calculus.pdc

## Sequent calculus

!include src/background/sequent-calculus.pdc

## Simply-typed lambda calculus

!include src/background/simply-typed-lambda-calculus.pdc

## Calculus of constructions

!include src/background/calculus-of-constructions.pdc

## Linear logic

!include src/background/linear-logic.pdc

## Interaction nets

!include src/background/interaction-nets.pdc

## Elementary affine logic

!include src/background/elementary-affine-logic.pdc

## Optimal reduction

!include src/background/optimal-reduction.pdc

\pagebreak

# Architectural overview

!include src/architecture.pdc

# Frontend language

!include src/frontend-language.pdc

# Core language

!include src/core-language.pdc

# Dependent elementary affine logic

!include src/dependent-elementary-affine-logic.pdc

# Low-level execution model

!include src/low-level-execution-model.pdc

# Execution extensions

!include src/execution-extensions.pdc

# Machine targets

!include src/machine-targets.pdc

# Future directions

!include src/future-directions.pdc

# Appendices

## Examples

!include src/appendices/examples.pdc

\pagebreak

# References
