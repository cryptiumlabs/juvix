---
title: Juvix — Language Reference
lang: en-GB
titlepage: true
titlepage-color: "06386e"
titlepage-text-color: "FFFFFF"
titlepage-rule-color: "FFFFFF"
titlepage-rule-height: 1
toc-own-page: true
mainfont: DejaVuSerifCondensed
fontsize: 8pt
author: \small Christopher Goes, Marty Stumpf, Jeremy Ornelas, Andy Morris, Asher Manning
date: \today \ - \textit{Prerelease}
urlcolor: cyan
abstract: Juvix synthesises a high-level frontend syntax, dependent-linearly-typed core language, and low-level parallelisable
          optimally-reducing execution model into a single unified stack for writing formally verifiable, efficiently executable
          smart contracts which can be deployed to a variety of distributed ledgers.
          \par
          Juvix's compiler architecture is purpose-built from the ground up for the particular requirements and economic trade-offs
          of the smart contract use case — it prioritises behavioural verifiability, semantic precision, and output code efficiency over compilation speed,
          syntactical familiarity, and backwards compatibility with existing blockchain virtual machines.
          \par
          Machine-assisted proof search, declarative deployment tooling, type & usage inference, and alternative spatiotemporal dataflow representations facilitate
          integration of low-developer-overhead property verification into the development process.
          An interchain abstraction layer representing ledgers as first-class objects enables seamless cross-chain programming and type-safe runtime reconfiguration.
          \par
          This document is designed to be a first-principles explanation of Juvix. No familiarity with the theoretical background is assumed.
          Readers previously acquainted with the lambda calculus, sequent calculus, simply-typed lambda calculus, the calculus of constructions,
          linear logic, interaction nets, elementary affine logic, and Lamping's optimal reduction algorithm may skip the associated subsections in chapter five.
---

\pagebreak


# Motivation

!include src/motivation.pdc

# Typographical conventions

!include src/typographical-conventions.pdc

# Prior work

!include src/prior-work.pdc

# Reasoning

!include src/reasoning.pdc

# Theoretical background

!include src/theoretical-background.pdc

## Lambda calculus

!include src/background/lambda-calculus.pdc

## Sequent calculus

!include src/background/sequent-calculus.pdc

## Simply-typed lambda calculus

!include src/background/simply-typed-lambda-calculus.pdc

## Calculus of constructions

!include src/background/calculus-of-constructions.pdc

## Linear logic

!include src/background/linear-logic.pdc

## Interaction nets

!include src/background/interaction-nets.pdc

## Elementary affine logic

!include src/background/elementary-affine-logic.pdc

## Optimal reduction

!include src/background/optimal-reduction.pdc

\pagebreak

# Architectural overview

!include src/architecture.pdc

# Frontend language

!include src/frontend-language.pdc

# Core language

!include src/core-language.pdc

# Core optimisation

!include src/core-optimisation.pdc

# Erased core language

!include src/erased-core-language.pdc

# Elementary affine core

!include src/elementary-affine-core.pdc

# Low-level execution model

!include src/low-level-execution-model.pdc

# Cost accounting

!include src/cost-accounting.pdc

# Machine targets

!include src/machine-targets.pdc

# Distributed ledger integration

!include src/distributed-ledger-integration.pdc

# Future directions

!include src/future-directions.pdc

# Appendices

## Examples

!include src/appendices/examples.pdc

\pagebreak

# References
