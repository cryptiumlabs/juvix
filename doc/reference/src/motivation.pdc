Selected out by the twin Darwinian reapers of language network-effect path-dependence and latency-over-correctness content delivery incentives, secure large-scale long-running digital systems are a virtually nonexistent breed.

- Ethereum contract losses ($xxx million). Many unexploited issues (cite 0x bug).
- Failing air traffic control systems.

Payment is made, but instead made later and unevenly, often by individuals who end up rendered vulnerable instead of empowered by poorly engineered technology. Worse, this information asymmetry has begun to be explicitly understood and exploited by the surveillance capitalist sect of Silicon Valley, who now engineer misleading patterns into product UX and continuously work to evade the best efforts of browser & extension manufacturers to provide privacy to their users, a tactic that should be regarded with the same disgust with which the CIA's (ultimately ineffective) research into mind control in the late 60s was.

(cite sources)

Although the underlying cryptographic primitives provide a great deal of individual protection, the resulting large-scale systems tend to devolve into the base power dynamics, with individuals having little chance against a terrorist group or nation state.

This result is overdetermined & difficult to precisely allocate causal responsibility for, but certainly a substantial contributor is the sheer difficulty and cost of formally verifying complex software systems.

The approach to security must be construtive & compositional, so that sets of proofs can be imported & reused along with the libraries which are commonly utilized. The approach must result in standards of succinct proofs which can be embedded by the manufacturers of user-facing software which tightly constrain the opaque behaviour of complex backend codebases. The approach must reduce the costs of formally verifying software to the point where doing so, even with a high discount rate on damage inflicted by future bugs, is economically rational. With the distributed ledger infrastructure there plausibly exists a window to rearchitect.

Juvix aims to realise this ideal by embedding a sufficiently expressive, composable, and developer-friendly verification system into a purpose-built smart contract programming language which can be efficienctly executed on a variety of distributed ledgers.
