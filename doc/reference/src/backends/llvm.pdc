Target LLVM IR, with parallel (thread?) support.

Full backend.

Experiment with "unrolling" the basic interaction net evaluator case switch by some degree $k$, such that intermediate allocations can be optimised away at compile-time - code size will be $c ^ k$ with $c$ the number of branches, but that's still fine for a few levels of unrolling.

This transformation is trivially semantics-preserving in the single-thread case and no additional bookkeeping is necessary. In the multi-thread case, if two threads start reduction less than $k$ hops from each other (hop = wire between nodes), they may reduce overlapping primary pairs, which could be problematic. We could either attempt to eliminate this possibility at compile time, which will require a fair bit of knowledge about where parallel reduction will occur (but perhaps possible, especially with explicit annotations), or reduce optimistically in parallel, insert synchronisation points where necessary, and revert conflicting changes in a semantics-preserving way - an approach which is more complicated to reason about, but doesn't require compile-time knowledge of "distance" between threads rewriting the graph in parallel.


