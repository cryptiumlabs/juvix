## Dependently-typed languages

Prior dependently-typed languages: Idris, Agda, Coq. Have seen some work in verification of other code but not in programs written directly in the language.

Only one real example targeting this use-case: Idris. Impressive but falls short of the requirements needed for wide deployment: inefficient compilation output, too much effort required to write proofs, not enough engineering effort dedicated to compiler minutae.

Economics of e.g. web development do not favor dependently-typed languages since speed is more important than safety. Smart contracts are different.

## Linearly-typed languages

Rust, partial but already useful. Haskell, working on it. Not yet available for smart contracts.

## Dependently-typed smart contracts

One prior work [@safer-smart-contracts-through-type-driven-development] wrote an Idris [@idris-systems-programming-meets-full-dependent-types] backend targeting Ethereum's LLL language [@lisp-like-language]. Juvix shares many of the goals outlined in that paper, but the approach described failed to take advantage of well-known optimizations such as tail-call optimization and handicapped itself by compiling to LLL instead of directly to EVM opcodes. The effects system described therein may be a sensible model for smart contract programs written in Juvix but is out of scope of this paper.

Formality [@formality] was a substantial inspiration for this work, particularly the low-level interaction net execution model. Juvix differs in its decisions to include a frontend language in which programmers will write directly, implement a larger core language and more complex low-level execution model, trade some simplicity in compiler architecture for output performance where the performance gains are substantial, and automate the tedious bureaucracy of elementary affine logic box placement. In the future Juvix may support Formality Core as a compile target.
