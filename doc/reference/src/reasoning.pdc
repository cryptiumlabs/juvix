What changes does Juvix make from these prior systems, and why will the solutions proposed fix the problems previously encountered & realise the criteria outlined previously?

Juvix is efficiently executable in machine time through a novel execution model & an expressive typesystem permitting aggressive optimization and efficiently verifiable in developer time through proof bureaucracy automation & composable verification. The rigor of the type system enables composition of contracts to a degree of complexity not possible with less precise languages, and the ability to deploy to multiple ledgers provides flexibility to and reduces development costs for language users. 

## Machine-time-efficient execution

### Optimal, parallelizable, higher-order-friendly evaluation

Juvix utilizes a fundamentally different evaluation model (as compared to present functional programming languages), based on recent theoretical advances in optimal lambda calculus reduction using interaction nets, which avoids any unnecessary duplication of reducible subexpressions, parallelizes by default, dynamically fuses composable terms at runtime, and handles higher-order functions & lexical closures efficiently without garbage collection. To take maximal advantage of this evaluation model, Juvix translates high-level algebraic datatypes into pure lambda calculus representations. In cases where optimal reduction requires too much bookkeeping or imposes undesired overhead, Juvix compiles subterms directly into rewrite rules which still enjoy the native parallelism and strong confluence properties of the interaction net model.

### Linear dependent types obviate garbage collection and ensure type erasure

Second: maximally expressive linear types render garbage collection unnecessary, in both the optimal reduction and alternative compiler paths, and faciliate aggressive optimizations.

### Discrete-cost optimization

Third: discrete optimization against a known cost model machine backend (e.g. blockchain VM with gas). Can search space.

### Proofs become optimizations

Prove equivalent reduction paths, compiler can choose which to use.

### Hint & bypass compiler when necessary

Expose underlying VM primitives, expose interpreter, allow safe rewrites to more efficient implementations.

## Developer-time-efficient formal proof construction

### Proof-generation bureaucracy automation

Graph search for asserted properties, step-through tactics, assert or prototype now & prove later.

### Composable proof ecosystem

Libraries of proofs for common functionality, "proof interfaces" for common data structures.

## Expanding the frontier of possible complexity

### Reduce the costs of verification



1. Make safety cheaper, smart contracts need it, enable more complex systems
    1. Correctness necessary
    1. Compile time doesn't matter, small programs, can supercompile/search
    1. Code reuse (even on-chain)

### Raise the threshold of possible complexity

"Abstraction limits" hit by interacting Ethereum contracts - typecheck across contracts, contracts can require types of callers / callees.

With integration of the compiler into the state machine - safe cross-contract optimizations using known types, safe upgrades (prove semantical equivalence, anyone can upgrade contract)

## Cross-ledger targeting

Juvix frontend & core languages are pretty independent of machine-level VM or hardware, can target anything from EVM to FPGA. Reduce "lock-in" of particular distributed ledgers with proprietary toolchains.
