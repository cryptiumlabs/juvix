Why will Juvix fix these problems?

## Machine-time-efficient execution

### Optimal, parallelizable reduction

First and foremost: radically different reduction model, based on recent theoretical advances in efficient lambda calculus reduction, with pragmatic compiler branching. Handles closures efficiently. High-level-language datatypes translated into lambda calculus terms to take advantage.

### Linear types obviate garbage collection

Second: maximally expressive linear types render garbage collection unnecessary, in both the optimal reduction and alternative compiler paths, and faciliate aggressive optimizations.

### Discrete-cost optimization

Third: discrete optimization against a known cost model machine backend (e.g. blockchain VM with gas). Can search space.

### Proofs become optimizations

Prove equivalent reduction paths, compiler can choose which to use.

### Hint & bypass compiler when necessary

Expose underlying VM primitives, expose interpreter, allow safe rewrites to more efficient implementations.

## Developer-time-efficient formal proof construction

### Proof-generation bureaucracy automation

Graph search for asserted properties, step-through tactics, assert or prototype now & prove later.

### Composable proof ecosystem

Libraries of proofs for common functionality, "proof interfaces" for common data structures.

## Expanding the frontier of possible complexity

### Reduce the costs of verification



1. Make safety cheaper, smart contracts need it, enable more complex systems
    1. Correctness necessary
    1. Compile time doesn't matter, small programs, can supercompile/search
    1. Code reuse (even on-chain)

### Raise the threshold of possible complexity

"Abstraction limits" hit by interacting Ethereum contracts - typecheck across contracts, contracts can require types of callers / callees.

With integration of the compiler into the state machine - safe cross-contract optimizations using known types, safe upgrades (prove semantical equivalence, anyone can upgrade contract)

## Cross-ledger targeting

Juvix frontend & core languages are pretty independent of machine-level VM or hardware, can target anything from EVM to FPGA. Reduce "lock-in" of particular distributed ledgers with proprietary toolchains.
