* Juvix
** Pipeline <<Juvix/Pipeline>>
- _Relies on_
  + [[Core]]
  + [[Frontend]]
  + [[Environment]]
  + [[Library]]
** Backends
- [[Backends]] are the targets for optimized code output specific to a
  platform
- Currently the LLVM backend will serve as the reference
  implementation
- The following backends are planned
  1. LLVM
  2. Michelson
  3. WASM
     - Most likely through LLVM
  4. Various Arithmetic Circuits
     - For use in ZKP's
*** ArithmeticCircuit
**** Groth
- place holder module until we have our groth
  setup done
- _Relies on_
  + [[Library]]
**** ZKP
- _Relies on_
  + [[ArithmeticCircuit/Compilation]]
  + [[Groth]]
  + [[Library]]
**** Compilation <<ArithmeticCircuit/Compilation>>
- _Relies on_
  + [[Compilation/Environment]]
  + [[Memory]]
  + [[ArithmeticCircuit/Compilation/Types]]
  + [[ArithmeticCircuit/Parameterisation]]
  + [[ErasedAnn]]
  + [[Usage]]
  + [[Library]]
***** Environment <<Compilation/Environment>>
- _Relies on_
  + [[Memory]]
  + [[ArithmeticCircuit/Compilation/Types]]
  + [[Library]]
***** Memory
- _Relies on_
  + [[Library]]
  + [[HashMap]]
***** Types <<ArithmeticCircuit/Compilation/Types>>
Provides the various types needed for the arithmetic circuit
backend
- Expression covers the gambit of arithmetic circuit expressions
- _Relies on_
  + [[ArithmeticCircuit/Parameterisation]]
  + [[ErasedAnn]]
  + [[Library]]
**** Parameterisation <<ArithmeticCircuit/Parameterisation>>
- _Relies on_
  + [[Booleans]]
  + [[FieldElements]]
  + [[Integers]]
  + [[Parameterisation]]
  + [[Library]]
***** Booleans
- _Relies on_
  + [[FieldElements]]
  + [[Parameterisation]]
  + [[Library]]
***** FieldElements
- _Relies on_
  + [[Parameterisation]]
  + [[Library]]
***** Integers
- _Relies on_
  + [[FieldElements]]
  + [[Parameterisation]]
  + [[Library]]
*** LLVM
- Serves as the LLVM backend compiler to Juvix.
- This is an alternative to the interpreter provided.
**** DSL
Serves as a mini DSL layer above LLVM
- _Relies on_
  + [[Codegen]]
  + [[Library]]
***** What is included?
1. _Relink_
   - gives a declarative way to do a bunch of links and relinks
**** Translation <<LLVM/Translation>>
Translates erased core terms (must be EAC-typable) to native interaction nets in LLVM, evaluates it, and reads-back the resulting term.
TODO: Separate out the common logic from the interpreter & this file into a shared module.
- _Relies on_
  + [[JIT]]
  + [[MonadEnvironment]]
  + [[Net/Environment]]
  + [[Types]]
  + [[Types]]
  + [[INetIR/Types]]
  + [[InteractionNet]]
  + [[Backends/Graph]]
  + [[Interface]]
  + [[Nets/Default]]
  + [[Library]]
**** Codegen
- _Relies on_
  + [[Block]]
  + [[Constants]]
  + [[Codegen/Graph]]
  + [[Codegen/Shared]]
  + [[Codegen/Types]]
***** Block
- Has the code necessary to generate LLVM Code
- _Relies on_
  + [[Codegen/Shared]]
  + [[Codegen/Types]]
  + [[Library]]
  + [[HashMap]]
***** Constants
Module for predefined constants
- _Relies on_
  + [[Library]]
***** Default <<Codegen/Default>>
This module provides the default environment to run LLVM code in
***** Shared <<Codegen/Shared>>
Shared between Types and Sum
- _Relies on_
  + [[Library]]
  + [[HashMap]]
***** Sum
Provides a mechanism for defining Sum types
- Has the code to encode a sum type via what is defined by the user or
  what is defined to create the interaction net system.
- _Relies on_
  + [[Constants]]
  + [[Codegen/Shared]]
  + [[Library]]
  + [[HashMap]]
***** Types <<Codegen/Types>>
- _Relies on_
  + [[Codegen/Shared]]
  + [[Sum]]
  + [[Library]]
  + [[HashMap]]
***** Graph <<Codegen/Graph>>
Serves as a front end for the Graph folder
- _Relies on_
  + [[Graph/Debug]]
  + [[Definitions]]
  + [[Operations]]
****** Debug <<Graph/Debug>>
Serves as a module for various debugging functions
- _Relies on_
  + [[Block]]
  + [[Operations]]
  + [[Codegen/Types]]
  + [[Library]]
****** Definitions
Operations necessary to update nodes
- =mainPort=, =auxiliary1= \dots =auxiliary4= allocation
  | Part       | Alloca Or Malloc |
  |------------+------------------|
  | MainPort   | Malloc top level |
  | Auxiliary1 | Malloc top level |
  | Auxiliary2 | Malloc top level |
  | Auxiliary3 | Malloc top level |
  | Auxiliary4 | Malloc top level |
- =mallocNodeH= Allocation
  + layout :
    Node[portSize | PortArray[portLocation | NodePtr] | DataArray[Data]]
  | Part         | Alloca Or Malloc                   |
  |--------------+------------------------------------|
  | Node         | Malloc                             |
  | portSize     | Stored on Node malloc              |
  | PortArray    | Malloc                             |
  | DataArray    | Malloc Maybe                       |
  | PortLocation | (Null) Allocad from PortArray Call |
  | NodePtr      | (Null) Allocad from PortArray Call |
  | Data         | (Null) Allocad from DataArray Call |
  + _Sub allocation functions used_
    * =mallocNode=
      | node | Malloc |
    * =allocaNumPortNum=
      | portsSize | Alloca |
    * =mallocPortsH=
      | portArray | Malloc |
    * =mallocDataH=
      | dataArray | Malloc |
  + the values that are null will be set from outside when the node
    is instantiated.
    * Data will be **Allocad**
    * Port Location is shown to be **malloc** above by =mainPort=
      \dots =Auxiliary4=. However in the future we may **alloca** a value
      to store here
    * NodePtr is **mallocd** in the same way this node is, and thus
      is external
- Notably PortLocation, NodePtr, and Data are not allocated here,
  but are instead sent in.
- Currently =defineMainPort=, =defineAuxiliary1= \dots
  =defineAuxiliary4= malloc the first four ports, and this is what
  link sets for the nodes.
  + This has some trade offs, namely we don't have to alloca more
    ports, however this will lead to waste if say =auxiliary4= is
    never used.
  + In the future this should turn to an alloca, and thus to
    dealloc a node, we need not iterate over i.
- For deallocation, just deallocate the node pointer itself
  + Currently, node pointers are allocated when nodes are made, and
    so are not the responsibility of a node to deallocate all the
    pointers.
    * this however is up to the Net representation themselves, and
      thus should modify the default deallocate node functionality
- _Relies on_
  + [[Block]]
  + [[Graph/Debug]]
  + [[Operations]]
  + [[Codegen/Types]]
  + [[Library]]
****** Operations
Functions that help with more complex Graph operations
- _Relies on_
  + [[Block]]
  + [[Codegen/Types]]
  + [[Library]]
**** JIT
- _Relies on_
  + [[Execution]]
  + [[JIT/Types]]
  + [[Library]]
***** Execution
- _Relies on_
  + [[JIT/Types]]
  + [[Library]]
***** Types <<JIT/Types>>
- _Relies on_
  + [[INetIR/Types]]
  + [[Library]]
**** Net
***** API
- _Relies on_
  + [[Codegen]]
  + [[EAC]]
  + [[EAC/Types]]
  + [[Library]]
***** Environment <<Net/Environment>>
- Serves as the default environment for executing EAC code
- _Relies on_
  + [[Codegen]]
  + [[API]]
  + [[EAC]]
  + [[Defs]]
  + [[MonadEnvironment]]
  + [[EAC/Types]]
  + [[Library]]
  + [[HashMap]]
***** EAC
- =EAC= serves as the place where the interaction net rules for the
  EAC layer gets run
- The form given to =EAC= is not the base EAC AST, but instead a
  pre processed =EAC= graph that the initial graph will be made on
- _Allocation_
  + layout :
    eac{tag | NodePtr*[portSize | PortArray[portLocation | NodePtr]* | DataArray[Data]*]}
    * Similar to the one in Graph, however it also has the eac tag
   | Part         | Alloca Or Malloc                   |
   |--------------+------------------------------------|
   | eac          | Malloc                             |
   | tag          | Stored on Eac Malloc               |
   | NodePtr*     | Malloc from =mallocNode=           |
   | portSize     | Stored on Node Malloc              |
   | PortArray    | Malloc                             |
   | DataArray    | Malloc Maybe                       |
   | PortLocation | (Null) Allocad from PortArray Call |
   | NodePtr      | (Null) Allocad from PortArray Call |
   | Data         | (Null) Allocad from DataArray Call |
- Node Pointers are allocated at node creation time, so not the
  responsibility of the node to de-allocate, but instead uses the
  default strategy laid out in [[Codegen/Graph]]
- _Relies on_
  + [[Codegen]]
  + [[DSL]]
  + [[EAC/Debug]]
  + [[Defs]]
  + [[MonadEnvironment]]
  + [[EAC/Types]]
  + [[Library]]
  + [[HashMap]]
****** Debug <<EAC/Debug>>
Serves as a module for various debugging functions
- _Relies on_
  + [[Codegen]]
****** Defs
- Specializes the functions in Graph to fit [[Net/EAC/Types]]
  + Later in the DSL Layer!
- Generates the =find_edge= and =isBothPrimary= function with the =eal= type.
- Also generates the proper types associated with them
- Also has some miscellaneous debug information
- _Relies on_
  + [[Codegen]]
  + [[DSL]]
  + [[EAC/Types]]
  + [[Library]]
****** MonadEnvironment
- This serves as the monad in which all operations are run
- This is an extension of EACState
  + Sadly we can't extend types easily in Haskell, hence the
    boilerplate in this file
- _Relies on_
  + [[Codegen]]
  + [[Library]]
  + [[HashMap]]
****** Types <<EAC/Types>>
- _Relies on_
  + [[Codegen]]
  + [[Library]]
*** Michelson
- _Relies on_
  + [[Michelson/Compilation]]
  + [[Michelson/Parameterisation]]
**** Contract <<Michelson/Contract>>
This module provides a default contract environment
**** Optimisation
- This is a simple optimization strategy which replaces sequences of
  Michelson instructions with equivalent sequences of fewer
  instructions.
  + At the moment nontrivial programs are unlikely to compile to
    the smallest equivalent Michelson instruction sequence,
- but little time has been spent on optimization so far - a high
  degree should be possible; the Haskell typesystem provides very
  strong guarantees.
  + A more interesting / potentially more effective strategy might
    be to search the space of equivalent Michelson programs,
    which at small program sizes using bounded heuristic search
    should be computationally feasible -
    then choose the one with the fewest instructions (or based on
    some other gas-estimation preference function).
- _Relies on_
  + [[Michelson/Compilation/Types]]
  + [[Library]]
**** Parameterisation <<Michelson/Parameterisation>>
- _Relies on_
  + [[Michelson/Compilation]]
  + [[Michelson/Compilation/Types]]
  + [[Michelson/Compilation/Types]]
  + [[Michelson/Contract]]
  + [[DSL/Environment]]
  + [[Instructions]]
  + [[InstructionsEff]]
  + [[Interpret]]
  + [[NameSymbol]]
  + [[Prim]]
  + [[Parameterisation]]
  + [[Types]]
  + [[Library]]
  + [[HashMap]]
**** Compilation <<Michelson/Compilation>>
- Entrypoints into compilation from core terms to Michelson terms & contracts.
- _Relies on_
  + [[Michelson/Compilation/Types]]
  + [[VirtualStack]]
  + [[DSL/Environment]]
  + [[Instructions]]
  + [[InstructionsEff]]
  + [[Optimisation]]
  + [[Types]]
  + [[Usage]]
  + [[Library]]
***** Types <<Michelson/Compilation/Types>>
- Types used internally by the Michelson backend.
- _Relies on_
  + [[Types]]
  + [[Library]]
***** VirtualStack
- Serves as a virtual stack over Michelson
- This stack has a few properties
  + The values on this stack may or may not be on the real
    stack. However for convention this should be largely ignored,
    except when you wish to do an operation like pair
    * This can be fixed in the future
    * Until then, one should filter out the virtual stack items
- We keep virtual items on the ="stack"= as that makes the details
  on whether something is constant propagation or not act
  consistently with each other.
  + After all, what may not be a constant now, may be in the
    future, or vice versa!
- Import with qualified and the name of =VStack=
- _Relies on_
  + [[Michelson/Compilation/Types]]
  + [[Instructions]]
  + [[Usage]]
  + [[Library]]
  + [[HashMap]]
**** DSL
***** Contract <<DSL/Contract>>
- _Relies on_
  + [[Library]]
***** Environment <<DSL/Environment>>
- _Relies on_
  + [[Michelson/Compilation/Types]]
  + [[VirtualStack]]
  + [[Usage]]
  + [[Library]]
***** Instructions
- This module serves as a lower layer DSL that is just a binding
  over the untyped instruction bindings
- _Relies on_
  + [[Michelson/Compilation/Types]]
  + [[Untyped]]
  + [[Library]]
***** InstructionsEff
- This module includes a higher level DSL which each instruction
  has a stack effect
  + This is similar to the base LLVM bindings we have.
  + So for example, emitting an =add=, eats two items from the
    virtual stack, and adds an =Instr.Add= instruction to the
    sequence of instructions to execute
- For constant progoation, have a function say take-2 that looks at
  the top two items in the stack and then returns back either if
  they were constants or not and dispatches logic based on that
- _Relies on_
  + [[Michelson/Compilation/Types]]
  + [[VirtualStack]]
  + [[DSL/Environment]]
  + [[Instructions]]
  + [[Untyped]]
  + [[Utils]]
  + [[Types]]
  + [[Usage]]
  + [[Library]]
  + [[Library]]
***** Interpret
- _Relies on_
  + [[Michelson/Compilation/Types]]
  + [[DSL/Contract]]
  + [[Library]]
***** Untyped
- _Relies on_
  + [[Library]]
***** Utils
- _Relies on_
  + [[Instructions]]
  + [[Untyped]]
  + [[Types]]
  + [[Usage]]
  + [[Library]]
** Core
- _Relies on_
  + [[NameSymbol]]
  + [[Erasure]]
  + [[Core/Pipeline]]
  + [[Translate]]
  + [[Types]]
  + [[Usage]]
  + [[Types]]
  + [[FrontendContextualise]]
  + [[Environment]]
  + [[FrontendDesugar]]
  + [[Library]]
*** FromFrontend
- _Relies on_
  + [[Context]]
  + [[NameSymbol]]
  + [[HR]]
  + [[IR]]
  + [[Base]]
  + [[Parameterisation]]
  + [[Translate]]
  + [[Usage]]
  + [[FrontendContextualise]]
  + [[Types]]
  + [[Library]]
*** Pipeline <<Core/Pipeline>>
- _Relies on_
  + [[Michelson]]
  + [[ErasedAnn]]
  + [[Erasure]]
  + [[HR]]
  + [[IR]]
  + [[Translate]]
  + [[Types]]
  + [[Usage]]
  + [[Library]]
** Encoding
*** Encoding
- This provides generic functions used by the various encodings in
  this directory
- _Relies on_
  + [[Encoding/Types]]
  + [[Library]]
  + [[HashMap]]
*** Mendler
- Gives a =Mendler= encoding from an =ADT=.
- This file is not done as Ι have yet to find a way to convert any
  general recursive function into a proper =Mendler= form.
- This however will do the boilerplate of changing an =ADT= to
  =Mendler= and the structure of a case expression into proper
  =Mendler= form
- _Relies on_
  + [[Encoding]]
  + [[Encoding/Types]]
  + [[Library]]
  + [[HashMap]]
*** Scott
- Gives a =Scott= encoding from an =ADT= and works properly for case
  expressions
- Overall this encoding just works™
- _Relies on_
  + [[Encoding]]
  + [[Encoding/Types]]
  + [[Library]]
  + [[HashMap]]
*** Types <<Encoding/Types>>
- _Relies on_
  + [[Library]]
  + [[HashMap]]
** INetIR
- _Relies on_
  + [[JSON]]
  + [[INetIR/Types]]
*** JSON
- _Relies on_
  + [[Library]]
*** Types <<INetIR/Types>>
- _Relies on_
  + [[Library]]
** Interpreter
- Although slower than [[Backends]], the interpreter serves as a
  reference point to play, modify, and debug features that will go
  in the various compiler backends
*** InteractionNet
- _Relies on_
  + [[Types]]
  + [[InteractionNet/Default]]
  + [[Parser]]
  + [[InteractionNet/Translation]]
  + [[Type]]
**** Default <<InteractionNet/Default>>
Gives the default execution environment for netToAst
Can be added to via core translation
- _Relies on_
  + [[InteractionNet/Shared]]
  + [[Type]]
  + [[Library]]
  + [[HashMap]]
**** NodeInterface
- Serves as a generic lens layer for various Node types in interaction nets
  1. Primary port details
     - Open or Bound?
  2. Auxiliary port details
     - Open or Bound?
  3. Type Classes aliases for having just a Primary port, or an
     Auxiliary port and a Primary, or two Auxiliary ports and a
     primary, and so forth.
- _Relies on_
  + [[Library]]
**** Parser
- Parses the syntax according to the formal =BNF=
- _Relies on_
  + [[InteractionNet/Default]]
  + [[InteractionNet/Shared]]
  + [[Type]]
  + [[Library]]
  + [[HashMap]]
**** Shared <<InteractionNet/Shared>>
- _Relies on_
  + [[Library]]
**** Translation <<InteractionNet/Translation>>
- Translates the default abstract syntax into Interaction nets
  + Also translates the net into the an ast
- _Relies on_
  + [[Types]]
  + [[Interface]]
  + [[Nets/Default]]
  + [[NodeInterface]]
  + [[InteractionNet/Shared]]
  + [[Type]]
  + [[Library]]
  + [[HashMap]]
**** Type
- Serves as the AST for all operations on [[Nets/Default]]
- Resembles the =BOHM= syntax/operation set, however it alters the
  operation set quite a bit
  + _Added_
    1. Notion of some kind of primitive value
    2. Curry 1-3
       - This allows custom functions to be manifested on primitive
         values
  + _Removed_
    1. =Letrec=
       - While here, it isn't fully implemented
    2. Hard coded math operations
       - This has been moved to primitive value operations
- _Relies on_
  + [[InteractionNet/Shared]]
  + [[Library]]
**** Backends
***** Env
- Env serves as the environment for running the back-ends
  + This includes the diagnostic information about how the code is ran
  + Also includes the effect handler types and the runner functions
    for them
- Also gives functions needed to increment diagnostic information
  + see =incGraphStepSize= and =sequentalStep=
  + File will also be imported in [[Nets]] due to these two functions
- _Relies on_
  + [[Interface]]
  + [[Library]]
***** Graph <<Backends/Graph>>
- This is an implementation of said interfacing using =FGL=
- This code will imported in Tests as a possible back-end for testing.
  + This back-end is more useful than [[Maps]] as it can produce
    graphical outputs, see [[Visualize]]
- _Relies on_
  + [[Env]]
  + [[Interface]]
  + [[NodeInterface]]
  + [[Library]]
***** Interface
- Interface serves as a file that has common types between the various
  back ends along with two interfaces each back-end must support
  + This also includes functions derived from the interface functions!
- This file will be the file [[Nets]] will import as it provides the
  interface along with derived functions
- _Relies on_
  + [[NodeInterface]]
  + [[Library]]
***** Maps
- this is an implementation of said interface using the =EnumMap= data structure
- This code will be imported in Tests as a possible back-end for testing
- _Relies on_
  + [[Env]]
  + [[Interface]]
  + [[NodeInterface]]
  + [[Library]]
**** Nets
***** Combinators
- An evaluation for a simple combination calculus language, only has
  three ports
  1. Con
  2. Dup
  3. Era
- _Relies on_
  + [[Env]]
  + [[Interface]]
  + [[NodeInterface]]
  + [[Library]]
***** Default <<Nets/Default>>
- An evaluator for the Default Language
- Serves as a reference way of creating interaction nets
- _Relies on_
  + [[Env]]
  + [[Interface]]
  + [[NodeInterface]]
  + [[InteractionNet/Shared]]
  + [[Library]]
** Visualize
*** Dot
- Generates a dot file in order to produce a simple image of a
  interaction net
- Also provides a way of generating gifs (and the images used to
  generate said gif), displaying every reduction step until the term
  is normalized
- _Relies on_
  + [[Env]]
  + [[Backends/Graph]]
  + [[Nets/Default]]
  + [[Library]]
  + [[Visualize/Graph]]
*** Graph <<Visualize/Graph>>
- A simple function for showing the graph as a proper net
- Really should be improved upon or removed
- _Relies on_
  + [[Library]]
