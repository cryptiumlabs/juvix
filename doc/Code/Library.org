* Backends
** Michelson
*** Setup <<Michelson/Setup>>
*** app
**** Main
*** src
**** Juvix
***** Backends
****** Michelson
- _Relies on_
  + [[Compilation]]
  + [[Michelson/Parameterisation]]
******* Contract <<Michelson/Contract>>
This module provides a default contract environment
******* Optimisation
- This is a simple optimization strategy which replaces sequences of
  Michelson instructions with equivalent sequences of fewer
  instructions.
  + At the moment nontrivial programs are unlikely to compile to
    the smallest equivalent Michelson instruction sequence,
- but little time has been spent on optimization so far - a high
  degree should be possible; the Haskell typesystem provides very
  strong guarantees.
  + A more interesting / potentially more effective strategy might
    be to search the space of equivalent Michelson programs,
    which at small program sizes using bounded heuristic search
    should be computationally feasible -
    then choose the one with the fewest instructions (or based on
    some other gas-estimation preference function).
- _Relies on_
  + [[Compilation/Types]]
  + [[Library]]
******* Parameterisation <<Michelson/Parameterisation>>
- _Relies on_
  + [[Compilation]]
  + [[Compilation/Types]]
  + [[Compilation/Types]]
  + [[Michelson/Contract]]
  + [[DSL/Environment]]
  + [[Instructions]]
  + [[InstructionsEff]]
  + [[Interpret]]
  + [[Common/NameSymbol]]
  + [[Prim]]
  + [[Core/Parameterisation]]
  + [[Core/Types]]
  + [[Library]]
  + [[HashMap]]
******* Compilation
- Entrypoints into compilation from core terms to Michelson terms & contracts.
- _Relies on_
  + [[Compilation/Types]]
  + [[VirtualStack]]
  + [[DSL/Environment]]
  + [[Instructions]]
  + [[InstructionsEff]]
  + [[Optimisation]]
  + [[ErasedAnn/Types]]
  + [[Core/Usage]]
  + [[Library]]
******** Types <<Compilation/Types>>
- Types used internally by the Michelson backend.
- _Relies on_
  + [[ErasedAnn/Types]]
  + [[Library]]
******** VirtualStack
- Serves as a virtual stack over Michelson
- This stack has a few properties
  + The values on this stack may or may not be on the real
    stack. However for convention this should be largely ignored,
    except when you wish to do an operation like pair
    * This can be fixed in the future
    * Until then, one should filter out the virtual stack items
- We keep virtual items on the ="stack"= as that makes the details
  on whether something is constant propagation or not act
  consistently with each other.
  + After all, what may not be a constant now, may be in the
    future, or vice versa!
- Import with qualified and the name of =VStack=
- _Relies on_
  + [[Compilation/Types]]
  + [[Instructions]]
  + [[Core/Usage]]
  + [[Library]]
  + [[HashMap]]
******* DSL
******** Contract <<DSL/Contract>>
- _Relies on_
  + [[Library]]
******** Environment <<DSL/Environment>>
- _Relies on_
  + [[Compilation/Types]]
  + [[VirtualStack]]
  + [[Core/Usage]]
  + [[Library]]
******** Instructions
- This module serves as a lower layer DSL that is just a binding
  over the untyped instruction bindings
- _Relies on_
  + [[Compilation/Types]]
  + [[Untyped]]
  + [[Library]]
******** InstructionsEff
- This module includes a higher level DSL which each instruction
  has a stack effect
  + This is similar to the base LLVM bindings we have.
  + So for example, emitting an =add=, eats two items from the
    virtual stack, and adds an =Instr.Add= instruction to the
    sequence of instructions to execute
- For constant progoation, have a function say take-2 that looks at
  the top two items in the stack and then returns back either if
  they were constants or not and dispatches logic based on that
- _Relies on_
  + [[Compilation/Types]]
  + [[VirtualStack]]
  + [[DSL/Environment]]
  + [[Instructions]]
  + [[Untyped]]
  + [[Utils]]
  + [[ErasedAnn/Types]]
  + [[Core/Usage]]
  + [[Library]]
  + [[Library]]
******** Interpret
- _Relies on_
  + [[Compilation/Types]]
  + [[DSL/Contract]]
  + [[Library]]
******** Untyped
- _Relies on_
  + [[Library]]
******** Utils
- _Relies on_
  + [[Instructions]]
  + [[Untyped]]
  + [[ErasedAnn/Types]]
  + [[Core/Usage]]
  + [[Library]]
*** test
**** Spec <<Michelson/test/Spec>>
* Core
** Setup <<Core/Setup>>
** src
*** Juvix
**** Core
***** Parameterisation <<Core/Parameterisation>>
- _Relies on_
  + [[Library]]
  + [[HashMap]]
  + [[Library/NameSymbol]]
***** Translate
- _Relies on_
  + [[HR]]
  + [[IR]]
  + [[Utility]]
  + [[Library]]
***** Types <<Core/Types>>
- _Relies on_
  + [[EAC/Types]]
  + [[Erased]]
  + [[Erasure/Types]]
  + [[HR/Types]]
  + [[Typechecker]]
  + [[IR/Types]]
  + [[Core/Parameterisation]]
  + [[Library]]
***** Usage <<Core/Usage>>
- _Relies on_
  + [[Library]]
***** Utility
- _Relies on_
  + [[Library]]
***** Common
****** NameSpace
- _Relies on_
  + [[Library]]
  + [[HashMap]]
****** NameSymbol <<Common/NameSymbol>>
- _Relies on_
  + [[Library]]
****** Context
- Serves as the context for lower level programs of the =Juvix=
  Programming Language
- This is parameterized per phase which may store the type and
  term in slightly different ways
- _Relies on_
  + [[Precedence]]
  + [[NameSpace]]
  + [[Common/NameSymbol]]
  + [[Core/Usage]]
  + [[Library]]
  + [[Library]]
  + [[HashMap]]
******* Precedence
- _Relies on_
  + [[Library]]
***** EAC
- This directory contains the implementation of =Eal= and the inferred
  bracket checker on =Eal=
- _Relies on_
  + [[Check]]
  + [[ConstraintGen]]
  + [[EAC/Erasure]]
  + [[EAC/Parser]]
  + [[Solve]]
  + [[EAC/Types]]
****** Check
- A constraint checker for EAC.
- _Relies on_
  + [[ConstraintGen]]
  + [[Solve]]
  + [[EAC/Types]]
  + [[Core/Types]]
  + [[Library]]
****** ConstraintGen
- _Relies on_
  + [[EAC/Types]]
  + [[Erased/Types]]
  + [[Core/Types]]
  + [[Library]]
  + [[HashMap]]
****** Erasure <<EAC/Erasure>>
- _Relies on_
  + [[EAC/Types]]
  + [[Erased/Types]]
****** Parser <<EAC/Parser>>
- _Relies on_
  + [[EAC/Types]]
  + [[EAC/Types]]
  + [[Unit]]
  + [[Library]]
****** Solve
- A Z3 solver for the generated =Eal= Constraints
- Can generate multiple constraints that will be used along side the
  Bracket checker to confirm that the solved constraints Z3 gives us
  is correct
- _Relies on_
  + [[EAC/Types]]
  + [[Library]]
****** Types <<EAC/Types>>
- _Relies on_
  + [[Erased/Types]]
  + [[Library]]
  + [[HashMap]]
***** Erased
- _Relies on_
  + [[Erased/Evaluator]]
  + [[Erased/Types]]
  + [[Util]]
****** Evaluator <<Erased/Evaluator>>
- _Relies on_
  + [[Erased/Types]]
  + [[Library]]
  + [[HashMap]]
****** Extend <<Erased/Extend>>
- _Relies on_
  + [[HRAnn/Extend]]
  + [[IR/Types/Base]]
****** Util
- _Relies on_
  + [[Erased/Types]]
  + [[Library]]
****** Types <<Erased/Types>>
- _Relies on_
  + [[Erased/Extend]]
  + [[Erased/Types/Base]]
  + [[IR/Types/Base]]
  + [[IR/Types/Base]]
  + [[Core/Usage]]
  + [[Library]]
******* Base <<Erased/Types/Base>>
- _Relies on_
  + [[IR/Types]]
  + [[Core/Usage]]
  + [[Library]]
  + [[HashMap]]
***** ErasedAnn
- _Relies on_
  + [[Conversion]]
  + [[ErasedAnn/Types]]
****** Conversion
- _Relies on_
  + [[Erased]]
  + [[ErasedAnn/Types]]
  + [[Erasure/Types]]
  + [[Core/Types]]
  + [[Core/Usage]]
  + [[Library]]
****** Erasure <<ErasedAnn/Erasure>>
- _Relies on_
  + [[Erased/Types]]
  + [[ErasedAnn/Types]]
  + [[ErasedAnn/Types]]
  + [[Library]]
****** Prim
- This module represents the type which will be sent to the
  parameterisation
- the =Take= type is what a parameterisation will take coming in
- the =Return= type is what will be handed back to Core to evaluate
  and decide on the next steps. If this is a =Left= type checking
  has failed, if it's a =Right= then type checking will continue
- _Relies on_
  + [[ErasedAnn/Types]]
  + [[Core/Usage]]
  + [[Library]]
****** Types <<ErasedAnn/Types>>
- _Relies on_
  + [[IR/Types]]
  + [[Core/Usage]]
  + [[Library]]
***** Erasure <<Core/Erasure>>
- _Relies on_
  + [[Algorithm]]
  + [[Erasure/Types]]
****** Algorithm
- _Relies on_
  + [[Erased/Types]]
  + [[Erasure/Types]]
  + [[Erasure/Types]]
  + [[IR]]
  + [[Typechecker/Types]]
  + [[Core/Usage]]
  + [[Library]]
****** Types <<Erasure/Types>>
- _Relies on_
  + [[Erased/Types]]
  + [[Erased/Types]]
  + [[Erased/Types/Base]]
  + [[Typechecker]]
  + [[Typechecker/Types]]
  + [[IR/Types]]
  + [[IR/Types]]
  + [[Core/Usage]]
  + [[Library]]
***** HR
- _Relies on_
  + [[HR/Parser]]
  + [[HR/Types]]
****** Extend <<HR/Extend>>
- _Relies on_
  + [[IR/Types/Base]]
  + [[Library]]
****** Parser <<HR/Parser>>
- _Relies on_
  + [[HR/Types]]
  + [[Core/Types]]
  + [[Core/Usage]]
  + [[Library]]
****** Subst
- Runs a substitution algorithm over core
- _Relies on_
  + [[Common/NameSymbol]]
  + [[HR/Types]]
  + [[Core/Usage]]
  + [[Library]]
  + [[HashMap]]
****** Types <<HR/Types>>
- _Relies on_
  + [[HR/Extend]]
  + [[IR/Types/Base]]
***** HRAnn
- _Relies on_
  + [[HRAnn/Erasure]]
  + [[HRAnn/Types]]
****** Erasure <<HRAnn/Erasure>>
- _Relies on_
  + [[HR/Types]]
  + [[HRAnn/Types]]
  + [[TransformExt]]
  + [[Library]]
****** Extend <<HRAnn/Extend>>
- _Relies on_
  + [[IR/Types/Base]]
  + [[Core/Usage]]
  + [[Library]]
****** Types <<HRAnn/Types>>
- _Relies on_
  + [[HRAnn/Extend]]
  + [[IR/Types/Base]]
***** IR
- _Relies on_
  + [[IR/Evaluator]]
  + [[Typechecker]]
  + [[Typechecker]]
  + [[IR/Types]]
  + [[Library]]
****** Evaluator <<IR/Evaluator>>
This includes the evaluators (evalTerm and evalElim),
the value application function (vapp) and
the substitution functions (substTerm and substElim).
- _Relies on_
  + [[Typechecker/Types]]
  + [[IR/Types]]
  + [[IR/Types/Base]]
  + [[Core/Parameterisation]]
  + [[Library]]
****** TransformExt
Transformations between different extensions.
- _Relies on_
  + [[IR/Types]]
  + [[IR/Types/Base]]
  + [[Library]]
****** Typechecker
- _Relies on_
  + [[IR/Evaluator]]
  + [[Env]]
  + [[Typechecker/Types]]
  + [[IR/Types]]
  + [[IR/Types/Base]]
  + [[Core/Parameterisation]]
  + [[Core/Usage]]
  + [[Library]]
******* Env
- _Relies on_
  + [[IR/Evaluator]]
  + [[Typechecker/Types]]
  + [[IR/Types]]
  + [[IR/Types/Base]]
  + [[Core/Parameterisation]]
  + [[Core/Usage]]
  + [[Library]]
******* Types <<Typechecker/Types>>
- _Relies on_
  + [[IR/Types]]
  + [[IR/Types/Base]]
  + [[Core/Parameterisation]]
  + [[Core/Usage]]
  + [[Library]]
****** Types <<IR/Types>>
Quantitative type implementation inspired by
  Atkey 2018 and McBride 2016.
- _Relies on_
  + [[IR/Types/Base]]
  + [[Library]]
******* Base <<IR/Types/Base>>
- _Relies on_
  + [[Core/Usage]]
  + [[Library]]
  + [[HashMap]]
***** IRAnn
- _Relies on_
  + [[IRAnn/Erasure]]
  + [[IRAnn/Types]]
****** Erasure <<IRAnn/Erasure>>
- _Relies on_
  + [[TransformExt]]
  + [[IR/Types]]
  + [[IRAnn/Types]]
****** Types <<IRAnn/Types>>
- _Relies on_
  + [[IR/Types/Base]]
  + [[Core/Usage]]
  + [[Library]]
***** Parameterisations
****** All
- _Relies on_
  + [[Core/Parameterisation]]
  + [[Naturals]]
  + [[Unit]]
  + [[Library]]
****** Naturals
- _Relies on_
  + [[Core/Parameterisation]]
  + [[Library]]
****** Unit
- _Relies on_
  + [[Core/Parameterisation]]
  + [[Library]]
** test
*** Spec <<Core/test/Spec>>
* Frontend
** Setup <<Frontend/Setup>>
** src
*** Juvix
**** Frontend
- _Relies on_
  + [[Frontend/Parser]]
  + [[Frontend/Types]]
  + [[Library]]
  + [[Library/NameSymbol]]
***** Lexer
- _Relies on_
  + [[Library]]
***** Parser <<Frontend/Parser>>
- The front end parser for the Juvix Programming language
- Parsers with S at the end, eat the spaces at the end of the parse
- Parsers with SN at the end, eats the spaces and new lines at the
  end of the parse
- _Relies on_
  + [[Lexer]]
  + [[Frontend/Types]]
  + [[Frontend/Types/Base]]
  + [[Library]]
***** Types <<Frontend/Types>>
- This file defines the main ADT for the Juvix front end language.
- This ADT corresponds to the bnf laid out [[https://github.com/cryptiumlabs/juvix/blob/develop/doc/Frontend/syntax.org][here]].
- Later a trees that grow version of this will be implemented, so
  infix functions can better transition across syntax
- Note :: The names for the types in =ArrowData= are stored in the
          =ArrowGen= and not in =NamedType=
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[Types/Extend]]
  + [[Library]]
****** Base <<Frontend/Types/Base>>
- This file defines the main ADT for the Juvix front end language.
- This ADT corresponds to the bnf laid out [[https://github.com/cryptiumlabs/juvix/blob/develop/doc/Frontend/syntax.org][here]].
- Later a trees that grow version of this will be implemented, so
  infix functions can better transition across syntax
- Note :: The names for the types in =ArrowData= are stored in the
          =ArrowGen= and not in =NamedType=
- _Relies on_
  + [[Library]]
  + [[Library/Usage]]
****** Extend <<Types/Extend>>
- _Relies on_
  + [[Frontend/Types/Base]]
** test
*** Spec <<Frontend/test/Spec>>
* StandardLibrary
** Setup <<StandardLibrary/Setup>>
** src
*** Juvix
**** Library
- The standard Library for the project
  + Thus all code will depend on this module without stating otherwise
- Is mostly =Protolude= except with a few changes
  + _Additions_
    * ∨   :: Serves as an or function
    * ∧   :: Serves as an and function
    * |<< :: Serves as a map function
    * >>| :: Serves as the flip map function
  + _Changes_
    * The Capability library is imported and replaces the standard =MTL=
      constructs in =Protolude=
- _Relies on_
  + [[PrettyPrint]]
***** HashMap
- The HashMap for the codebase.
- Basically just imports Data.HashMap.Strict
  + While giving the operation =!?=.
- Every hash in the code base should use this, except when it needs
  to compare keys by the =Ordering= metric instead.
***** NameSymbol <<Library/NameSymbol>>
- _Relies on_
  + [[Library]]
***** PrettyPrint
***** Usage <<Library/Usage>>
- _Relies on_
  + [[Library]]
** test
*** Spec <<StandardLibrary/test/Spec>>
* Translate
** Setup <<Translate/Setup>>
** src
*** Juvix
**** FrontendContextualise
- order of Passes
  1. =ModuleOpen=
  2. =InfixPrecedence=
- _Relies on_
  + [[Context]]
  + [[Common/NameSymbol]]
  + [[Contextify/Transform]]
  + [[Contextify/Types]]
  + [[InfixPrecedence/Environment]]
  + [[InfixPrecedence/Environment]]
  + [[InfixPrecedence/Transform]]
  + [[ModuleOpen/Environment]]
  + [[ModuleOpen/Transform]]
  + [[RemoveDo/Types]]
  + [[Library]]
***** Environment <<FrontendContextualise/Environment>>
- _Relies on_
  + [[Context]]
  + [[NameSpace]]
  + [[Common/NameSymbol]]
  + [[Library]]
***** Contextify
****** Transform <<Contextify/Transform>>
- _Relies on_
  + [[Context]]
  + [[NameSpace]]
  + [[Common/NameSymbol]]
  + [[Contextify/Types]]
  + [[RemoveDo/Types]]
  + [[Library]]
****** Types <<Contextify/Types>>
- _Relies on_
  + [[Context]]
  + [[Common/NameSymbol]]
  + [[RemoveDo/Types]]
  + [[Library]]
***** InfixPrecedence
****** Environment <<InfixPrecedence/Environment>>
- _Relies on_
  + [[Context]]
  + [[FrontendContextualise/Environment]]
  + [[ShuntYard]]
  + [[InfixPrecedence/Types]]
  + [[ModuleOpen/Types]]
  + [[Library]]
****** Extend <<InfixPrecedence/Extend>>
- This pass removes the =Infix= form
  + Belongs to Table
    | Changed | Is a Sum Type of |
    |---------+------------------|
    | Infix   | Expression       |
- Thus one does not have to ever deal with
  #+begin_src haskell
    data Infix
      = Inf
        { infixLeft  :: Expression
        , infixOp    :: NameSymb
        , infixRight :: Expression
        }
      deriving (Show, Generic, NFData)
  #+end_src
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[ModuleOpen/Extend]]
  + [[ModuleOpen/Extend]]
  + [[Library]]
****** FreeVars
- FreeVars is an algorithm that checks for free symbols in the AST.
- The =ExcludedSet= holds the symbols defined... These are needed
  in case of a degenerate case like
  #+BEGIN_SRC ocaml
    let foo =
      let type point = {x : int, y : int} in
      let our-point  = {x = 3, y = 4} in
      our-point.x + our-point.y
  #+END_SRC
  + here we need to dismiss =our-point.x= and =our-point.y=, just
    filtering out =our-point= isn't enough! we have to check if the
    first-part of the name has =our-point=, since everything shares
    the same namespace
- TODO :: How do we handle this case?
  #+BEGIN_SRC ocaml
    mod Foo where
    let foo (x :: xs) = x + TopLevel.Foo.foo xs
    let foo []        = 0
  #+END_SRC
  + To Handle this, we need to unqualify the foo, and have the
    module handle the symbol allocation
- NOTE :: we assume in =nameifyAdt= which takes effect in the =\\=
  call to =nameifyLetType=, that definitions of constructors before
  this point can't be redefined
  + This means that if we have ordered definitions, we'll silently
    drop the calls to the old constructors.
  + Thus, please redefine the logic there to support such modes
- _Reasons to update_
  1. let's not being recursive
     - we assume lets are recursive, if this changes the code
       has to be updated to account for that'
  2. Language becomes ordered
     - see first note above
  3. Universe or Declaration talk about free variables
     - currently universe is unfinished, and are not
       first class
|
- FreeVars is an algorithm that checks for free symbols in the AST.
- The =ExcludedSet= holds the symbols defined... These are needed
  in case of a degenerate case like
  #+BEGIN_SRC ocaml
    let foo =
      let type point = {x : int, y : int} in
      let our-point  = {x = 3, y = 4} in
      our-point.x + our-point.y
  #+END_SRC
  + here we need to dismiss =our-point.x= and =our-point.y=, just
- _Relies on_
  + [[Common/NameSymbol]]
  + [[InfixPrecedence/Types]]
  + [[Library]]
****** ShuntYard
- This implements the Shunt Yard algorithm for determining the
  precedence of operations
- _Relies on_
  + [[Library]]
****** Transform <<InfixPrecedence/Transform>>
- _Relies on_
  + [[Context]]
  + [[NameSpace]]
  + [[Common/NameSymbol]]
  + [[InfixPrecedence/Environment]]
  + [[ShuntYard]]
  + [[InfixPrecedence/Types]]
  + [[ModuleOpen/Types]]
  + [[Library]]
****** Types <<InfixPrecedence/Types>>
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[InfixPrecedence/Extend]]
  + [[Library]]
***** ModuleOpen
****** Environment <<ModuleOpen/Environment>>
- _Relies on_
  + [[Context]]
  + [[NameSpace]]
  + [[Common/NameSymbol]]
  + [[FrontendContextualise/Environment]]
  + [[ModuleOpen/Types]]
  + [[RemoveDo/Types]]
  + [[Library]]
  + [[HashMap]]
****** Extend <<ModuleOpen/Extend>>
- This pass removes the =Infix= form
  + Belongs to Table
    | Changed        | Is a Sum Type of |
    |----------------+------------------|
    | ModuleOpen     | TopLevel         |
    | ModuleOpenExpr | Expression       |
- Thus one does not have to ever deal with
  #+begin_src haskell
    data ModuleOpen
      = Open ModuleName
      deriving (Show, Generic, NFData)
    data ModuleOpenExpr
      = OpenExpress
        { moduleOpenExprModuleN :: ModuleName
        , moduleOpenExprExpr    :: Expression }
      deriving (Show, Generic, NFData)
  #+end_src
- This pass with thus try to qualify all names as we go, turning
#+begin_src ocaml
  let foo =
    open Core in
    List.map f xs
  (* ====> *)
  let foo =
    Core.List.Map f xs
#+end_src
- for modules we can infer.
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemoveDo/Extend]]
  + [[RemoveDo/Extend]]
  + [[Library]]
****** Transform <<ModuleOpen/Transform>>
- _Relies on_
  + [[Context]]
  + [[NameSpace]]
  + [[ModuleOpen/Environment]]
  + [[ModuleOpen/Types]]
  + [[RemoveDo/Types]]
  + [[Library]]
****** Types <<ModuleOpen/Types>>
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[ModuleOpen/Extend]]
  + [[Library]]
**** FrontendDesugar
- Order of Passes
  1. =RemoveModule=
  2. =RemoveGuard=
  3. =RemoveCond=
  4. =CombineMultiple=
  5. =RemoveSignature=
  6. =RemovePunned=
  7. =RemoveDo=
- _Relies on_
  + [[Frontend/Types]]
  + [[CombineMultiple/Transform]]
  + [[RemoveCond/Transform]]
  + [[RemoveDo/Transform]]
  + [[RemoveDo/Types]]
  + [[RemoveGuard/Transform]]
  + [[RemoveModules/Transform]]
  + [[RemovePunned/Transform]]
  + [[RemoveSignature/Transform]]
  + [[Library]]
***** Abstractions
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[Library]]
***** CombineMultiple
****** Extend <<CombineMultiple/Extend>>
- This pass changes =FunctionLike=, =Function=, and =Let=
  + Belongs to Table
    | Changed      | Is a Sum Type of |
    |--------------+------------------|
    | Function     | TopLevel         |
    | Let          | Expression       |
    | FunctionLike | Function ∧ Let   |
- _Function Like changes_
  + Function Like now looks like
    #+begin_src haskell
      data FunctionLike a
        = Like
          { functionLikeArgs :: [Arg]
          , functionLikeBody :: a
          }
        deriving (Show, Generic, NFData)
    #+end_src
    * This pass removes the =Name= from the previous transform
- _Let changes_
  + Let now looks like
    #+begin_src haskell
      data Let
        = LetGroup
          { letName :: Symbol
          , letBindings :: NonEmpty (FunctionLike Expression)
          , letBody :: Expression
          }
        deriving (Show, Generic, NFData)
    #+end_src
    * In this pass we add =Name= from the previous Let type
- _Function changes_
  + Function now looks like
    #+begin_src haskell
      data Function
        = Func Symbol (NonEmpty (FunctionLike Expression))
    #+end_src
    * Namely this version adds symbol to the previous pass
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemoveCond/Extend]]
  + [[RemoveCond/Extend]]
  + [[Library]]
****** Transform <<CombineMultiple/Transform>>
- _Relies on_
  + [[CombineMultiple/Types]]
  + [[RemoveCond/Types]]
  + [[Library]]
****** Types <<CombineMultiple/Types>>
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[CombineMultiple/Extend]]
  + [[Library]]
***** RemoveCond
****** Extend <<RemoveCond/Extend>>
- This pass removes the =Do= form
 + Belongs to Table
   | Changed | Is a Sum Type of |
   |---------+------------------|
   | Cond    | Expression       |
- Thus one does not have to ever deal with
  #+begin_src haskell
    data Cond a
      = C (NonEmpty (CondLogic a))
      deriving (Show, Generic, NFData)
    data CondLogic a
      = CondExpression
          { condLogicPred :: Expression
          , condLogicBody :: a
          }
      deriving (Show, Generic, NFData)
  #+end_src
  after this pass
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemoveGuard/Extend]]
  + [[RemoveGuard/Extend]]
  + [[Library]]
****** Transform <<RemoveCond/Transform>>
- _Relies on_
  + [[RemoveCond/Types]]
  + [[RemoveGuard/Types]]
  + [[Library]]
****** Types <<RemoveCond/Types>>
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemoveCond/Extend]]
  + [[Library]]
***** RemoveDo
****** Extend <<RemoveDo/Extend>>
- This pass removes the =Do= form
 + Belongs to Table
   | Changed | Is a Sum Type of |
   |---------+------------------|
   | Do      | Expression       |
- Thus one does not have to ever deal with
  #+begin_src haskell
    data Do
      = Do'' (NonEmpty DoBody)
      deriving (Show, Generic, NFData)
    data DoBody
      = DoBody
        { doBodyName :: Maybe NameSymb,
          doBodyExpr :: Expression
        }
      deriving (Show, Generic, NFData)
  #+end_src
  after this pass
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemovePunned/Extend]]
  + [[RemovePunned/Extend]]
  + [[Library]]
****** Transform <<RemoveDo/Transform>>
- _Relies on_
  + [[RemoveDo/Types]]
  + [[RemovePunned/Types]]
  + [[Library]]
****** Types <<RemoveDo/Types>>
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemoveDo/Extend]]
  + [[Library]]
***** RemoveGuard
****** Extend <<RemoveGuard/Extend>>
- This pass changes =FunctionLike=
  + Belongs to Table
    | Changed      | Is a Sum Type of |
    |--------------+------------------|
    | FunctionLike | Function ∧ Let   |
- _Function Like changes_
  + Function Like now looks like
    #+begin_src haskell
      data FunctionLike a
        = Like
          { functionLikeName :: Symbol
          , functionLikeArgs :: [Arg]
          , functionLikeBody :: a
          }
        deriving (Show, Generic, NFData)
    #+end_src
    * This pass removes the =GuardBody= from the body.
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[Abstractions]]
  + [[RemoveModules/Extend]]
****** Transform <<RemoveGuard/Transform>>
- _Relies on_
  + [[RemoveGuard/Types]]
  + [[RemoveModules/Types]]
  + [[Library]]
****** Types <<RemoveGuard/Types>>
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemoveGuard/Extend]]
  + [[Library]]
***** RemoveModules
****** Extend <<RemoveModules/Extend>>
- This pass removes the =Module= and =ModuleE= form
 + Belongs to Table
   | Changed | Is a Sum Type of |
   |---------+------------------|
   | Module  | TopLevel         |
   | ModuleE | Expression       |
- Thus one does not have to ever deal with
  #+begin_src haskell
    data Module
      = Mod (FunctionLike (NonEmpty TopLevel))
      deriving (Show, Generic, NFData)
    data ModuleE
      = ModE
          { moduleEBindings :: FunctionLike (NonEmpty TopLevel)
          , moduleEBody :: Expression
          }
      deriving (Show, Generic, NFData)
  #+end_src
  after this pass
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[Types/Extend]]
  + [[Types/Extend]]
  + [[Library]]
****** Transform <<RemoveModules/Transform>>
- _Relies on_
  + [[Frontend/Types]]
  + [[RemoveModules/Types]]
  + [[Library]]
****** Types <<RemoveModules/Types>>
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemoveModules/Extend]]
  + [[Library]]
***** RemovePunned
****** Extend <<RemovePunned/Extend>>
- This pass removes the =Punned= form
 + Belongs to Table
   | Removed | Is a Sum Type of |
   |---------+------------------|
   | Punned  | NameSet          |
- Thus one does not have to ever deal with the =Punned= variant in
  #+begin_src haskell
    data NameSet t
      = Punned NameSymb
      | NonPunned NameSymb t
      deriving (Show, Generic, NFData)
  #+end_src
  after this pass
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemoveSignature/Extend]]
  + [[RemoveSignature/Extend]]
  + [[Library]]
****** Transform <<RemovePunned/Transform>>
- _Relies on_
  + [[RemovePunned/Types]]
  + [[RemoveSignature/Types]]
  + [[Library]]
****** Types <<RemovePunned/Types>>
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemovePunned/Extend]]
  + [[Library]]
***** RemoveSignature
****** Extend <<RemoveSignature/Extend>>
- This pass changes =Signature=, and =Function=
  + Belongs to Table
    | Changed   | Is a Sum Type of      |
    |-----------+-----------------------|
    | Function  | TopLevel              |
    | Signature | +TopLevel+ ∧ Function |
- _Signature changes_
  + We move Signature from TopLevel to Function
    #+begin_src haskell
      data Signature
        = Sig
            { signatureName :: Symbol
              -- Was a usage but can't alias for now
            , signatureUsage :: Maybe Expression
            , signatureArrowType :: Expression
            , signatureConstraints :: [Expression]
            }
        deriving (Show, Generic, NFData)
    #+end_src
- _Function changes_
  + Function now looks like
    #+begin_src haskell
      data Function
        = Func Symbol (NonEmpty (FunctionLike Expression)) (Maybe Signature)
    #+end_src
    * Namely this version adds a signature to upon the previous pass
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[CombineMultiple/Extend]]
  + [[CombineMultiple/Extend]]
  + [[Library]]
****** Transform <<RemoveSignature/Transform>>
- _Relies on_
  + [[CombineMultiple/Types]]
  + [[RemoveSignature/Types]]
  + [[Library]]
****** Types <<RemoveSignature/Types>>
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemoveSignature/Extend]]
  + [[Library]]
** test
*** Spec <<Translate/test/Spec>>
