* Core
** Setup <<Core/Setup>>
** src
*** Juvix
**** Core
***** Parameterisation
- _Relies on_
  + [[Library/NameSymbol]]
  + [[Library]]
  + [[HashMap]]
***** Translate
- _Relies on_
  + [[HR]]
  + [[IR]]
  + [[Utility]]
  + [[Library]]
***** Types <<Core/Types>>
- _Relies on_
  + [[EAC/Types]]
  + [[Erased]]
  + [[Erasure/Types]]
  + [[HR/Types]]
  + [[Typechecker]]
  + [[IR/Types]]
  + [[Parameterisation]]
  + [[Library]]
***** Usage <<Core/Usage>>
- _Relies on_
  + [[Library]]
***** Utility
- _Relies on_
  + [[Library]]
***** Common
****** NameSpace
- _Relies on_
  + [[Library]]
  + [[HashMap]]
****** NameSymbol <<Common/NameSymbol>>
- _Relies on_
  + [[Library]]
****** Context
- Serves as the context for lower level programs of the =Juvix=
  Programming Language
- This is parameterized per phase which may store the type and
  term in slightly different ways
- _Relies on_
  + [[Precedence]]
  + [[NameSpace]]
  + [[Common/NameSymbol]]
  + [[Core/Usage]]
  + [[Library]]
  + [[Library]]
  + [[HashMap]]
******* Precedence
- _Relies on_
  + [[Library]]
***** EAC
- This directory contains the implementation of =Eal= and the inferred
  bracket checker on =Eal=
- _Relies on_
  + [[Check]]
  + [[ConstraintGen]]
  + [[EAC/Erasure]]
  + [[EAC/Parser]]
  + [[Solve]]
  + [[EAC/Types]]
****** Check
- A constraint checker for EAC.
- _Relies on_
  + [[ConstraintGen]]
  + [[Solve]]
  + [[EAC/Types]]
  + [[Core/Types]]
  + [[Library]]
****** ConstraintGen
- _Relies on_
  + [[EAC/Types]]
  + [[Erased/Types]]
  + [[Core/Types]]
  + [[Library]]
  + [[HashMap]]
****** Erasure <<EAC/Erasure>>
- _Relies on_
  + [[EAC/Types]]
  + [[Erased/Types]]
****** Parser <<EAC/Parser>>
- _Relies on_
  + [[EAC/Types]]
  + [[EAC/Types]]
  + [[Unit]]
  + [[Library]]
****** Solve
- A Z3 solver for the generated =Eal= Constraints
- Can generate multiple constraints that will be used along side the
  Bracket checker to confirm that the solved constraints Z3 gives us
  is correct
- _Relies on_
  + [[EAC/Types]]
  + [[Library]]
****** Types <<EAC/Types>>
- _Relies on_
  + [[Erased/Types]]
  + [[Library]]
  + [[HashMap]]
***** Erased
- _Relies on_
  + [[Erased/Evaluator]]
  + [[Erased/Types]]
  + [[Util]]
****** Evaluator <<Erased/Evaluator>>
- _Relies on_
  + [[Erased/Types]]
  + [[Library]]
  + [[HashMap]]
****** Extend <<Erased/Extend>>
- _Relies on_
  + [[HRAnn/Extend]]
  + [[IR/Types/Base]]
****** Util
- _Relies on_
  + [[Erased/Types]]
  + [[Library]]
****** Types <<Erased/Types>>
- _Relies on_
  + [[Erased/Extend]]
  + [[Erased/Types/Base]]
  + [[IR/Types/Base]]
  + [[IR/Types/Base]]
  + [[Core/Usage]]
  + [[Library]]
******* Base <<Erased/Types/Base>>
- _Relies on_
  + [[IR/Types]]
  + [[Core/Usage]]
  + [[Library]]
  + [[HashMap]]
***** ErasedAnn
- _Relies on_
  + [[Conversion]]
  + [[ErasedAnn/Types]]
****** Conversion
- _Relies on_
  + [[Erased]]
  + [[ErasedAnn/Types]]
  + [[Erasure/Types]]
  + [[Core/Types]]
  + [[Core/Usage]]
  + [[Library]]
****** Erasure <<ErasedAnn/Erasure>>
- _Relies on_
  + [[Erased/Types]]
  + [[ErasedAnn/Types]]
  + [[ErasedAnn/Types]]
  + [[Library]]
****** Prim
- This module represents the type which will be sent to the
  parameterisation
- the =Take= type is what a parameterisation will take coming in
- the =Return= type is what will be handed back to Core to evaluate
  and decide on the next steps. If this is a =Left= type checking
  has failed, if it's a =Right= then type checking will continue
- _Relies on_
  + [[ErasedAnn/Types]]
  + [[Core/Usage]]
  + [[Library]]
****** Types <<ErasedAnn/Types>>
- _Relies on_
  + [[IR/Types]]
  + [[Core/Usage]]
  + [[Library]]
***** Erasure <<Core/Erasure>>
- _Relies on_
  + [[Algorithm]]
  + [[Erasure/Types]]
****** Algorithm
- _Relies on_
  + [[Erased/Types]]
  + [[Erasure/Types]]
  + [[Erasure/Types]]
  + [[IR]]
  + [[Typechecker/Types]]
  + [[Core/Usage]]
  + [[Library]]
****** Types <<Erasure/Types>>
- _Relies on_
  + [[Erased/Types]]
  + [[Erased/Types]]
  + [[Erased/Types/Base]]
  + [[Typechecker]]
  + [[Typechecker/Types]]
  + [[IR/Types]]
  + [[IR/Types]]
  + [[Core/Usage]]
  + [[Library]]
***** HR
- _Relies on_
  + [[HR/Parser]]
  + [[HR/Types]]
****** Extend <<HR/Extend>>
- _Relies on_
  + [[IR/Types/Base]]
  + [[Library]]
****** Parser <<HR/Parser>>
- _Relies on_
  + [[HR/Types]]
  + [[Core/Types]]
  + [[Core/Usage]]
  + [[Library]]
****** Subst
- Runs a substitution algorithm over core
- _Relies on_
  + [[Common/NameSymbol]]
  + [[HR/Types]]
  + [[Core/Usage]]
  + [[Library]]
  + [[HashMap]]
****** Types <<HR/Types>>
- _Relies on_
  + [[HR/Extend]]
  + [[IR/Types/Base]]
***** HRAnn
- _Relies on_
  + [[HRAnn/Erasure]]
  + [[HRAnn/Types]]
****** Erasure <<HRAnn/Erasure>>
- _Relies on_
  + [[HR/Types]]
  + [[HRAnn/Types]]
  + [[TransformExt]]
  + [[Library]]
****** Extend <<HRAnn/Extend>>
- _Relies on_
  + [[IR/Types/Base]]
  + [[Core/Usage]]
  + [[Library]]
****** Types <<HRAnn/Types>>
- _Relies on_
  + [[HRAnn/Extend]]
  + [[IR/Types/Base]]
***** IR
- _Relies on_
  + [[IR/Evaluator]]
  + [[Typechecker]]
  + [[Typechecker]]
  + [[IR/Types]]
  + [[Library]]
****** Evaluator <<IR/Evaluator>>
This includes the evaluators (evalTerm and evalElim),
the value application function (vapp) and
the substitution functions (substTerm and substElim).
- _Relies on_
  + [[Typechecker/Types]]
  + [[IR/Types]]
  + [[IR/Types/Base]]
  + [[Parameterisation]]
  + [[Library]]
****** TransformExt
Transformations between different extensions.
- _Relies on_
  + [[IR/Types]]
  + [[IR/Types/Base]]
  + [[Library]]
****** Typechecker
- _Relies on_
  + [[IR/Evaluator]]
  + [[Env]]
  + [[Typechecker/Types]]
  + [[IR/Types]]
  + [[IR/Types/Base]]
  + [[Parameterisation]]
  + [[Core/Usage]]
  + [[Library]]
******* Env
- _Relies on_
  + [[IR/Evaluator]]
  + [[Typechecker/Types]]
  + [[IR/Types]]
  + [[IR/Types/Base]]
  + [[Parameterisation]]
  + [[Core/Usage]]
  + [[Library]]
******* Types <<Typechecker/Types>>
- _Relies on_
  + [[IR/Types]]
  + [[IR/Types/Base]]
  + [[Parameterisation]]
  + [[Core/Usage]]
  + [[Library]]
****** Types <<IR/Types>>
Quantitative type implementation inspired by
  Atkey 2018 and McBride 2016.
- _Relies on_
  + [[IR/Types/Base]]
  + [[Library]]
******* Base <<IR/Types/Base>>
- _Relies on_
  + [[Core/Usage]]
  + [[Library]]
  + [[HashMap]]
***** IRAnn
- _Relies on_
  + [[IRAnn/Erasure]]
  + [[IRAnn/Types]]
****** Erasure <<IRAnn/Erasure>>
- _Relies on_
  + [[TransformExt]]
  + [[IR/Types]]
  + [[IRAnn/Types]]
****** Types <<IRAnn/Types>>
- _Relies on_
  + [[IR/Types/Base]]
  + [[Core/Usage]]
  + [[Library]]
***** Parameterisations
****** All
- _Relies on_
  + [[Parameterisation]]
  + [[Naturals]]
  + [[Unit]]
  + [[Library]]
****** Naturals
- _Relies on_
  + [[Parameterisation]]
  + [[Library]]
****** Unit
- _Relies on_
  + [[Parameterisation]]
  + [[Library]]
** test
*** Spec <<Core/test/Spec>>
* Frontend
** Setup <<Frontend/Setup>>
** src
*** Juvix
**** Frontend
- _Relies on_
  + [[Library/NameSymbol]]
  + [[Frontend/Parser]]
  + [[Frontend/Types]]
  + [[Library]]
***** Lexer
- _Relies on_
  + [[Library]]
***** Parser <<Frontend/Parser>>
- The front end parser for the Juvix Programming language
- Parsers with S at the end, eat the spaces at the end of the parse
- Parsers with SN at the end, eats the spaces and new lines at the
  end of the parse
- _Relies on_
  + [[Lexer]]
  + [[Frontend/Types]]
  + [[Frontend/Types/Base]]
  + [[Library]]
***** Types <<Frontend/Types>>
- This file defines the main ADT for the Juvix front end language.
- This ADT corresponds to the bnf laid out [[https://github.com/cryptiumlabs/juvix/blob/develop/doc/Frontend/syntax.org][here]].
- Later a trees that grow version of this will be implemented, so
  infix functions can better transition across syntax
- Note :: The names for the types in =ArrowData= are stored in the
          =ArrowGen= and not in =NamedType=
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[Types/Extend]]
  + [[Library]]
****** Base <<Frontend/Types/Base>>
- This file defines the main ADT for the Juvix front end language.
- This ADT corresponds to the bnf laid out [[https://github.com/cryptiumlabs/juvix/blob/develop/doc/Frontend/syntax.org][here]].
- Later a trees that grow version of this will be implemented, so
  infix functions can better transition across syntax
- Note :: The names for the types in =ArrowData= are stored in the
          =ArrowGen= and not in =NamedType=
- _Relies on_
  + [[Library/Usage]]
  + [[Library]]
****** Extend <<Types/Extend>>
- _Relies on_
  + [[Frontend/Types/Base]]
** test
*** Spec <<Frontend/test/Spec>>
* StandardLibrary
** Setup <<StandardLibrary/Setup>>
** src
*** Juvix
**** Library
- The standard Library for the project
  + Thus all code will depend on this module without stating otherwise
- Is mostly =Protolude= except with a few changes
  + _Additions_
    * ∨   :: Serves as an or function
    * ∧   :: Serves as an and function
    * |<< :: Serves as a map function
    * >>| :: Serves as the flip map function
  + _Changes_
    * The Capability library is imported and replaces the standard =MTL=
      constructs in =Protolude=
- _Relies on_
  + [[PrettyPrint]]
***** HashMap
- The HashMap for the codebase.
- Basically just imports Data.HashMap.Strict
  + While giving the operation =!?=.
- Every hash in the code base should use this, except when it needs
  to compare keys by the =Ordering= metric instead.
***** NameSymbol <<Library/NameSymbol>>
- _Relies on_
  + [[Library]]
***** PrettyPrint
***** Usage <<Library/Usage>>
- _Relies on_
  + [[Library]]
** test
*** Spec <<StandardLibrary/test/Spec>>
* Translate
** Setup <<Translate/Setup>>
** src
*** Juvix
**** FrontendContextualise
- order of Passes
  1. =ModuleOpen=
  2. =InfixPrecedence=
- _Relies on_
  + [[Context]]
  + [[Common/NameSymbol]]
  + [[Contextify/Transform]]
  + [[Contextify/Types]]
  + [[InfixPrecedence/Environment]]
  + [[InfixPrecedence/Environment]]
  + [[InfixPrecedence/Transform]]
  + [[ModuleOpen/Environment]]
  + [[ModuleOpen/Transform]]
  + [[RemoveDo/Types]]
  + [[Library]]
***** Environment <<FrontendContextualise/Environment>>
- _Relies on_
  + [[Context]]
  + [[NameSpace]]
  + [[Common/NameSymbol]]
  + [[Library]]
***** Contextify
****** Transform <<Contextify/Transform>>
- _Relies on_
  + [[Context]]
  + [[NameSpace]]
  + [[Common/NameSymbol]]
  + [[Contextify/Types]]
  + [[RemoveDo/Types]]
  + [[Library]]
****** Types <<Contextify/Types>>
- _Relies on_
  + [[Context]]
  + [[Common/NameSymbol]]
  + [[RemoveDo/Types]]
  + [[Library]]
***** InfixPrecedence
****** Environment <<InfixPrecedence/Environment>>
- _Relies on_
  + [[Context]]
  + [[FrontendContextualise/Environment]]
  + [[ShuntYard]]
  + [[InfixPrecedence/Types]]
  + [[ModuleOpen/Types]]
  + [[Library]]
****** Extend <<InfixPrecedence/Extend>>
- This pass removes the =Infix= form
  + Belongs to Table
    | Changed | Is a Sum Type of |
    |---------+------------------|
    | Infix   | Expression       |
- Thus one does not have to ever deal with
  #+begin_src haskell
    data Infix
      = Inf
        { infixLeft  :: Expression
        , infixOp    :: NameSymb
        , infixRight :: Expression
        }
      deriving (Show, Generic, NFData)
  #+end_src
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[ModuleOpen/Extend]]
  + [[ModuleOpen/Extend]]
  + [[Library]]
****** FreeVars
- FreeVars is an algorithm that checks for free symbols in the AST.
- The =ExcludedSet= holds the symbols defined... These are needed
  in case of a degenerate case like
  #+BEGIN_SRC ocaml
    let foo =
      let type point = {x : int, y : int} in
      let our-point  = {x = 3, y = 4} in
      our-point.x + our-point.y
  #+END_SRC
  + here we need to dismiss =our-point.x= and =our-point.y=, just
    filtering out =our-point= isn't enough! we have to check if the
    first-part of the name has =our-point=, since everything shares
    the same namespace
- TODO :: How do we handle this case?
  #+BEGIN_SRC ocaml
    mod Foo where
    let foo (x :: xs) = x + TopLevel.Foo.foo xs
    let foo []        = 0
  #+END_SRC
  + To Handle this, we need to unqualify the foo, and have the
    module handle the symbol allocation
- NOTE :: we assume in =nameifyAdt= which takes effect in the =\\=
  call to =nameifyLetType=, that definitions of constructors before
  this point can't be redefined
  + This means that if we have ordered definitions, we'll silently
    drop the calls to the old constructors.
  + Thus, please redefine the logic there to support such modes
- _Reasons to update_
  1. let's not being recursive
     - we assume lets are recursive, if this changes the code
       has to be updated to account for that'
  2. Language becomes ordered
     - see first note above
  3. Universe or Declaration talk about free variables
     - currently universe is unfinished, and are not
       first class
|
- FreeVars is an algorithm that checks for free symbols in the AST.
- The =ExcludedSet= holds the symbols defined... These are needed
  in case of a degenerate case like
  #+BEGIN_SRC ocaml
    let foo =
      let type point = {x : int, y : int} in
      let our-point  = {x = 3, y = 4} in
      our-point.x + our-point.y
  #+END_SRC
  + here we need to dismiss =our-point.x= and =our-point.y=, just
- _Relies on_
  + [[Common/NameSymbol]]
  + [[InfixPrecedence/Types]]
  + [[Library]]
****** ShuntYard
- This implements the Shunt Yard algorithm for determining the
  precedence of operations
- _Relies on_
  + [[Library]]
****** Transform <<InfixPrecedence/Transform>>
- _Relies on_
  + [[Context]]
  + [[NameSpace]]
  + [[Common/NameSymbol]]
  + [[InfixPrecedence/Environment]]
  + [[ShuntYard]]
  + [[InfixPrecedence/Types]]
  + [[ModuleOpen/Types]]
  + [[Library]]
****** Types <<InfixPrecedence/Types>>
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[InfixPrecedence/Extend]]
  + [[Library]]
***** ModuleOpen
****** Environment <<ModuleOpen/Environment>>
- _Relies on_
  + [[Context]]
  + [[NameSpace]]
  + [[Common/NameSymbol]]
  + [[FrontendContextualise/Environment]]
  + [[ModuleOpen/Types]]
  + [[RemoveDo/Types]]
  + [[Library]]
  + [[HashMap]]
****** Extend <<ModuleOpen/Extend>>
- This pass removes the =Infix= form
  + Belongs to Table
    | Changed        | Is a Sum Type of |
    |----------------+------------------|
    | ModuleOpen     | TopLevel         |
    | ModuleOpenExpr | Expression       |
- Thus one does not have to ever deal with
  #+begin_src haskell
    data ModuleOpen
      = Open ModuleName
      deriving (Show, Generic, NFData)
    data ModuleOpenExpr
      = OpenExpress
        { moduleOpenExprModuleN :: ModuleName
        , moduleOpenExprExpr    :: Expression }
      deriving (Show, Generic, NFData)
  #+end_src
- This pass with thus try to qualify all names as we go, turning
#+begin_src ocaml
  let foo =
    open Core in
    List.map f xs
  (* ====> *)
  let foo =
    Core.List.Map f xs
#+end_src
- for modules we can infer.
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemoveDo/Extend]]
  + [[RemoveDo/Extend]]
  + [[Library]]
****** Transform <<ModuleOpen/Transform>>
- _Relies on_
  + [[Context]]
  + [[NameSpace]]
  + [[ModuleOpen/Environment]]
  + [[ModuleOpen/Types]]
  + [[RemoveDo/Types]]
  + [[Library]]
****** Types <<ModuleOpen/Types>>
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[ModuleOpen/Extend]]
  + [[Library]]
**** FrontendDesugar
- Order of Passes
  1. =RemoveModule=
  2. =RemoveGuard=
  3. =RemoveCond=
  4. =CombineMultiple=
  5. =RemoveSignature=
  6. =RemovePunned=
  7. =RemoveDo=
- _Relies on_
  + [[Frontend/Types]]
  + [[CombineMultiple/Transform]]
  + [[RemoveCond/Transform]]
  + [[RemoveDo/Transform]]
  + [[RemoveDo/Types]]
  + [[RemoveGuard/Transform]]
  + [[RemoveModules/Transform]]
  + [[RemovePunned/Transform]]
  + [[RemoveSignature/Transform]]
  + [[Library]]
***** Abstractions
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[Library]]
***** CombineMultiple
****** Extend <<CombineMultiple/Extend>>
- This pass changes =FunctionLike=, =Function=, and =Let=
  + Belongs to Table
    | Changed      | Is a Sum Type of |
    |--------------+------------------|
    | Function     | TopLevel         |
    | Let          | Expression       |
    | FunctionLike | Function ∧ Let   |
- _Function Like changes_
  + Function Like now looks like
    #+begin_src haskell
      data FunctionLike a
        = Like
          { functionLikeArgs :: [Arg]
          , functionLikeBody :: a
          }
        deriving (Show, Generic, NFData)
    #+end_src
    * This pass removes the =Name= from the previous transform
- _Let changes_
  + Let now looks like
    #+begin_src haskell
      data Let
        = LetGroup
          { letName :: Symbol
          , letBindings :: NonEmpty (FunctionLike Expression)
          , letBody :: Expression
          }
        deriving (Show, Generic, NFData)
    #+end_src
    * In this pass we add =Name= from the previous Let type
- _Function changes_
  + Function now looks like
    #+begin_src haskell
      data Function
        = Func Symbol (NonEmpty (FunctionLike Expression))
    #+end_src
    * Namely this version adds symbol to the previous pass
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemoveCond/Extend]]
  + [[RemoveCond/Extend]]
  + [[Library]]
****** Transform <<CombineMultiple/Transform>>
- _Relies on_
  + [[CombineMultiple/Types]]
  + [[RemoveCond/Types]]
  + [[Library]]
****** Types <<CombineMultiple/Types>>
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[CombineMultiple/Extend]]
  + [[Library]]
***** RemoveCond
****** Extend <<RemoveCond/Extend>>
- This pass removes the =Do= form
 + Belongs to Table
   | Changed | Is a Sum Type of |
   |---------+------------------|
   | Cond    | Expression       |
- Thus one does not have to ever deal with
  #+begin_src haskell
    data Cond a
      = C (NonEmpty (CondLogic a))
      deriving (Show, Generic, NFData)
    data CondLogic a
      = CondExpression
          { condLogicPred :: Expression
          , condLogicBody :: a
          }
      deriving (Show, Generic, NFData)
  #+end_src
  after this pass
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemoveGuard/Extend]]
  + [[RemoveGuard/Extend]]
  + [[Library]]
****** Transform <<RemoveCond/Transform>>
- _Relies on_
  + [[RemoveCond/Types]]
  + [[RemoveGuard/Types]]
  + [[Library]]
****** Types <<RemoveCond/Types>>
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemoveCond/Extend]]
  + [[Library]]
***** RemoveDo
****** Extend <<RemoveDo/Extend>>
- This pass removes the =Do= form
 + Belongs to Table
   | Changed | Is a Sum Type of |
   |---------+------------------|
   | Do      | Expression       |
- Thus one does not have to ever deal with
  #+begin_src haskell
    data Do
      = Do'' (NonEmpty DoBody)
      deriving (Show, Generic, NFData)
    data DoBody
      = DoBody
        { doBodyName :: Maybe NameSymb,
          doBodyExpr :: Expression
        }
      deriving (Show, Generic, NFData)
  #+end_src
  after this pass
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemovePunned/Extend]]
  + [[RemovePunned/Extend]]
  + [[Library]]
****** Transform <<RemoveDo/Transform>>
- _Relies on_
  + [[RemoveDo/Types]]
  + [[RemovePunned/Types]]
  + [[Library]]
****** Types <<RemoveDo/Types>>
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemoveDo/Extend]]
  + [[Library]]
***** RemoveGuard
****** Extend <<RemoveGuard/Extend>>
- This pass changes =FunctionLike=
  + Belongs to Table
    | Changed      | Is a Sum Type of |
    |--------------+------------------|
    | FunctionLike | Function ∧ Let   |
- _Function Like changes_
  + Function Like now looks like
    #+begin_src haskell
      data FunctionLike a
        = Like
          { functionLikeName :: Symbol
          , functionLikeArgs :: [Arg]
          , functionLikeBody :: a
          }
        deriving (Show, Generic, NFData)
    #+end_src
    * This pass removes the =GuardBody= from the body.
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[Abstractions]]
  + [[RemoveModules/Extend]]
****** Transform <<RemoveGuard/Transform>>
- _Relies on_
  + [[RemoveGuard/Types]]
  + [[RemoveModules/Types]]
  + [[Library]]
****** Types <<RemoveGuard/Types>>
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemoveGuard/Extend]]
  + [[Library]]
***** RemoveModules
****** Extend <<RemoveModules/Extend>>
- This pass removes the =Module= and =ModuleE= form
 + Belongs to Table
   | Changed | Is a Sum Type of |
   |---------+------------------|
   | Module  | TopLevel         |
   | ModuleE | Expression       |
- Thus one does not have to ever deal with
  #+begin_src haskell
    data Module
      = Mod (FunctionLike (NonEmpty TopLevel))
      deriving (Show, Generic, NFData)
    data ModuleE
      = ModE
          { moduleEBindings :: FunctionLike (NonEmpty TopLevel)
          , moduleEBody :: Expression
          }
      deriving (Show, Generic, NFData)
  #+end_src
  after this pass
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[Types/Extend]]
  + [[Types/Extend]]
  + [[Library]]
****** Transform <<RemoveModules/Transform>>
- _Relies on_
  + [[Frontend/Types]]
  + [[RemoveModules/Types]]
  + [[Library]]
****** Types <<RemoveModules/Types>>
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemoveModules/Extend]]
  + [[Library]]
***** RemovePunned
****** Extend <<RemovePunned/Extend>>
- This pass removes the =Punned= form
 + Belongs to Table
   | Removed | Is a Sum Type of |
   |---------+------------------|
   | Punned  | NameSet          |
- Thus one does not have to ever deal with the =Punned= variant in
  #+begin_src haskell
    data NameSet t
      = Punned NameSymb
      | NonPunned NameSymb t
      deriving (Show, Generic, NFData)
  #+end_src
  after this pass
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemoveSignature/Extend]]
  + [[RemoveSignature/Extend]]
  + [[Library]]
****** Transform <<RemovePunned/Transform>>
- _Relies on_
  + [[RemovePunned/Types]]
  + [[RemoveSignature/Types]]
  + [[Library]]
****** Types <<RemovePunned/Types>>
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemovePunned/Extend]]
  + [[Library]]
***** RemoveSignature
****** Extend <<RemoveSignature/Extend>>
- This pass changes =Signature=, and =Function=
  + Belongs to Table
    | Changed   | Is a Sum Type of      |
    |-----------+-----------------------|
    | Function  | TopLevel              |
    | Signature | +TopLevel+ ∧ Function |
- _Signature changes_
  + We move Signature from TopLevel to Function
    #+begin_src haskell
      data Signature
        = Sig
            { signatureName :: Symbol
              -- Was a usage but can't alias for now
            , signatureUsage :: Maybe Expression
            , signatureArrowType :: Expression
            , signatureConstraints :: [Expression]
            }
        deriving (Show, Generic, NFData)
    #+end_src
- _Function changes_
  + Function now looks like
    #+begin_src haskell
      data Function
        = Func Symbol (NonEmpty (FunctionLike Expression)) (Maybe Signature)
    #+end_src
    * Namely this version adds a signature to upon the previous pass
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[CombineMultiple/Extend]]
  + [[CombineMultiple/Extend]]
  + [[Library]]
****** Transform <<RemoveSignature/Transform>>
- _Relies on_
  + [[CombineMultiple/Types]]
  + [[RemoveSignature/Types]]
  + [[Library]]
****** Types <<RemoveSignature/Types>>
- _Relies on_
  + [[Frontend/Types/Base]]
  + [[RemoveSignature/Extend]]
  + [[Library]]
** test
*** Spec <<Translate/test/Spec>>
